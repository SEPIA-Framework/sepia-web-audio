<!doctype html>
<html lang="en-us">
<head>
	<meta charset="utf-8">
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SEPIA Web Audio Processor Test</title>

	<script src="src/visualization/uPlot.iife.min.js"></script>
	<script src="src/visualization/uPlot-lazy.min.js"></script>
	<script src="src/visualization/uPlot-lazy-heatmap.min.js"></script>
	<link rel="stylesheet" href="src/visualization/uPlot.min.css">

	<script src="src/polyfills/audioworklet-polyfill.js"></script>
	<script type="text/javascript" src="src/processor.js"></script>
	
	<script type="text/javascript" src="src/resources/pcm-convert.js"></script>
	<!--<script type="text/javascript" src="test-buffer.js"></script>-->
	
	<style>
	* {
		box-sizing: border-box;
	}
	html, body {
		font-family: sans-serif;
		text-align: center;
	}
	#mainView > div {
		margin: 16px 8px;
	}
	button {
		display: inline-block;
		margin: 8px;
	}
	label, input {
		margin: 8px;
	}
	input.small {
		width: 72px;
	}
	select {
		height: 21px;
	}
	.contorlGroup {
		display: flex;
		align-items: center;
		align-content: center;
		flex-wrap: wrap;
	}
	.contorlGroup.center {
		justify-content: center;
	}
	#mainView {
		display: inline-block;
		width: 100%;
		max-width: 1024px;
		text-align: center;
		padding: 16px; 
		margin:0;
	}
    #status {
		display: inline-block;
		width: 90px;
		height: 90px;
		background: #aaa;
		border-radius: 50%;
		margin: 8px;
    }
	#status.ready {
		background: #000;
	}
	#status.listening {
		background: #ff3355;
	}
	#status.voiceactivity {
		background: #16abc3;
	}
	#status.insequence {
		background: #33ee88;
	}
	#logMessages {
		max-height: 50vh;
		white-space: pre;
		text-align: left;
		overflow: auto;
		border: 1px solid currentColor;
		padding: 16px;
		overflow: auto;
		font-size: 15px;
	}
	.chart {
		margin: 30px 0;
		height: 128px;
		border: 1px solid #000;
		overflow: auto;
	}
	#volumeMeterNodeOutput {
		flex: 1 1 auto;
		min-width: 128px;
		border: 1px solid currentColor;
		margin: 8px;
	}
	#volumeMeterNodeOutput > div {
		margin: 0;
		padding: 0;
		height: 21px;
		width: 0%;
		background: #ff3355;
	}
	#waveEncoderGateState {
		width: 18px;
		height: 18px;
		background: #eee;
		border-radius: 9px;
	}
	#waveEncoderGateState.open {
		background: #0f5;
	}
	#waveEncoderGateState.close {
		background: #000;
		border-radius: 0;
	}
	</style>
</head>
<body>
<div id="mainView">
	<h1>SEPIA Web Audio Processor</h1>
	<div id="info">Info: []</div>
	<div id="status"></div>
	<div>
		<button onclick="createRecorder(this);">Create</button>
		<button onclick="startRecording(this);">Start</button>
		<button onclick="stopRecording(this);">Stop</button>
		<button onclick="releaseRecorder(this);">Release</button>
	</div>
	<div class="contorlGroup center">
		<label>Target Sample-Rate:</label><select id="sampleRateSelector">
			<option value="">Auto</option>
			<option value="16000" selected>16000</option>
			<option value="8000">8000</option>
			<option value="96000">96000</option>
		</select>
		<label>Audio Source:</label><select id="sourceTypeSelector">
			<option value="mic" selected>Microphone</option>
			<option value="whiteNoise">White-Noise Generator</option>
			<option value="file1">File Stream 1</option>
			<option value="file2">File Stream 2</option>
		</select>
		<!--<label>White-Noise Test:</label><input id="useWhiteNoiseRecorder" type="checkbox">-->
	</div>
	<div id="logMessages">- Log -</div>
	<div class="contorlGroup">
		<label><b>Volume-Meter</b></label>
		<label>Gain:</label><input id="volumeMeterGain" class="small" value="5.0" onchange="setVolumeGain();">
		<label>Meter:</label><div id="volumeMeterNodeOutput"><div></div></div>
	</div>
	<div class="contorlGroup">
		<label><b>Resampler (Speex WASM)</b></label>
		<label>Sample-Rate:</label><input id="resamplerSampleRate" class="small" value="16000" onchange="setResamplerSampleRate(this);" placeholder="16000">
		<label>Buffer-Size:</label><input id="resamplerBufferSize" class="small" value="512" onchange="setResamplerBufferSize(this);" placeholder="512">
		<label>Quality:</label><input id="resampleQuality" class="small" value="7" onchange="setResampleQuality(this);" placeholder="0-10 (0: fastest, 10: best)">
	</div>
	<div class="contorlGroup">
		<label><b>Wave Encoder</b></label>
		<label>Lookback (ms):</label><input id="waveEncoderLookback" class="small" value="0" onchange="setWaveEncoderLookback(this);">
		<label>Record Max. (ms):</label><input id="waveEncoderRecordMax" class="small" value="6000" onchange="setWaveEncoderRecordMax(this);"><div style="flex: 1 0 100%;"></div>
		<label>Gate:</label><div id="waveEncoderGateState"></div><label></label>
		<label>Control:</label><button onclick="waveEncoderSetGate('open');">Capture</button><button onclick="waveEncoderSetGate('close');">Stop</button><label></label>
		<label>Export:</label><button onclick="waveEncoderGetWave();">Get Wave-File</button>
		<button onclick="waveEncoderGetBuffer();">Show Buffer</button>
	</div>
	<div id="chart1" class="chart"></div>
	<div id="chart2" class="chart"></div>
	<!--<div id="chart3" class="chart"></div>-->
</div>
<script type='text/javascript'>
	var infoElement = document.getElementById('info');
	var statusElement = document.getElementById('status');
	var targetSampleRateSelector = document.getElementById("sampleRateSelector");
	targetSampleRateSelector.onchange = function(){
		targetSampleRate = +targetSampleRateSelector.value;
	};
	var sourceSelector = document.getElementById("sourceTypeSelector");
	var logElement = document.getElementById('logMessages');
	
	function showLogMessage(msg, data){
		var info = (typeof data == "object")? JSON.stringify(data) : data; //JSON.stringify(data, "", 2) : data;
		logElement.textContent += "\n" + (new Date().toLocaleTimeString()) + " - " + (msg + " - " + info);
		logElement.scrollTo(0, logElement.scrollHeight);
	}
	
	//callbacks:
	
	function onRecorderReady(info){
		statusElement.className = "ready";
		showLogMessage("onReady", info);
		infoElement.textContent = "Info: Input Sample-Rate=" + info.inputSampleRate;
		console.log("onReady", info);
	}
	
	function onRecorderInitError(err){
		statusElement.className = "";
		showLogMessage("ERROR - onInitError", err);
		console.error("onInitError", err);
	}
	
	function onAudioStart(info){
		statusElement.className = "listening"; 
		showLogMessage("onaudiostart", info);
		console.log("onaudiostart", info);
	}
	
	function onAudioEnd(info){
		statusElement.className = "ready";
		showLogMessage("onaudioend", info);
		console.log("onaudioend", info);
	}
	
	function onRecorderRelease(info){
		statusElement.className = "";
		showLogMessage("onrelease", info);
		console.log("onrelease", info);
	}
	
	function onProcessorError(err){
		statusElement.className = "";
		showLogMessage("ERROR - Processor - onerror", err);
		console.error("onerror", err);
	}
	
	function onDebugLog(msg){
		console.log("debugLog", msg);
	}
	
	//main:

	var rec;
	var targetSampleRate = 16000;
	
	//set correct modules folder
	SepiaFW.webAudio.defaultProcessorOptions.moduleFolder = "src/modules";
	
	async function createRecorder(btn){
		//audio source
		var useWhiteNoiseTest = false; //document.getElementById("useWhiteNoiseRecorder").checked;
		var customSource = undefined;
		var audioSource = sourceSelector.value;
		if (audioSource == "whiteNoise"){
			//customSourceNode: white-noise
			useWhiteNoiseTest = true;
		}else if (audioSource.indexOf("file") == 0){
			//customSourceNode: file audio buffer
			try {
				customSource = await createFileSource(audioSource);
			}catch (err){
				onRecorderInitError(err);
				return;
			}
		}else{
			//default: mic
		}
		
		//create processor modules
		var volumeMeter = {
			name: 'volume-meter',
			setup: {
				onmessage: setVolume1,		//info: 'onmessage' has the parameters: 'data' and 'processNodes'
				options: {
					//use AudioWorklet options directly or common "setup" field for worklet and workers:
					processorOptions: {
						smoothingFactor: volSmooth
					}
				}
			}
		};
		var resampler = {
			name: 'resample-switch', //'buffer-switch',
			setup: {
				onmessage: testBuffer,
				sendToModules: [3],		//index as given to processor - 0: source, 1: volume-meter, 2: resample-switch, 3: wave-encoder
				options: {
					processorOptions: {
						targetSampleRate: resamplerSampleRate, 	//16000,
						resampleQuality: resamplerQuality, 		//7,
						bufferSize: resamplerBufferSize, 		//512,
						passThroughMode: 1,		//0: none, 1: original (float32), 2: 16Bit PCM - NOTE: NOT resampled
						calculateRmsVolume: true
					}
				}
			}
		};
		var waveEncoder = {
			name: 'wave-encoder',
			type: 'worker',
			handle: {},		//will be updated on init. with ref. to node.
			setup: {
				onmessage: waveEncoderMessage,
				options: {
					setup: {
						inputSampleRate: resamplerSampleRate,	//output sampleRate of previous module, if undefined take targetSampleRate
						inputSampleSize: resamplerBufferSize,	//output bufferSize of previous module
						lookbackBufferMs: waveEncoderLookback,
						//recordBufferLimitKb: 600,
						recordBufferLimitMs: waveEncoderRecordMax
					}
				}
			}
		};
		window.waveEncoder = waveEncoder;
				
		//create processor
		rec = new SepiaFW.webAudio.Processor({
			onaudiostart: onAudioStart,
			onaudioend: onAudioEnd,
			onrelease: onRecorderRelease,
			onerror: onProcessorError,
			targetSampleRate: targetSampleRate,
			//targetBufferSize: 512,
			modules: [volumeMeter, resampler, waveEncoder],
			destinationNode: undefined,		//defaults to: audioContext.destination
			startSuspended: true,
			debugLog: onDebugLog,
			customSourceTest: useWhiteNoiseTest,
			customSource: customSource
			
		}, function(msg){
			//Init. ready
			onRecorderReady(msg);
			
		}, function(err){
			//Init. error
			onRecorderInitError(err);
		});
	}
	
	function startRecording(btn){
		if (rec){
			rec.start();
		}
	}
	
	function stopRecording(btn){
		if (rec){
			rec.stop();
			//UI specific:
			setVolumeBar({volume: 0.0});
		}
	}
	
	function releaseRecorder(btn){
		if (rec){
			rec.release();
		}
	}
	
	//Custom audio nodes
	
	async function createFileSource(fileId){
		var fileUrl;
		if (fileId == "file2"){
			fileUrl = "test-sounds/chatter_counting.ogg";
		}else{
			fileUrl = "test-sounds/traffic_counting.ogg";
		}
		showLogMessage("createFileSource", fileUrl); 
		return SepiaFW.webAudio.createFileSource(fileUrl, {
			targetSampleRate: targetSampleRate
		});
	}
	
	//Audio node data/visualizations:
	
	var volMeterOutBar = document.getElementById('volumeMeterNodeOutput').firstChild;
	var volGain = +document.getElementById('volumeMeterGain').value;
	var volSmooth = 0.8;	//0=none, 1=max
	function setVolumeGain(input){
		volGain = input || +document.getElementById('volumeMeterGain').value;
	}
	setVolumeGain();
	function setVolumeBar(data){
		//console.log("volume-bar data", data);
		var volPercent = Math.min(100, Math.round(volGain * data.volume * 100));
		volMeterOutBar.style.width = (volPercent + "%");
	}
	
	var resamplerSampleRate = 16000;
	var resamplerBufferSize = 512;
	var resamplerQuality = 7;
	function setResamplerSampleRate(inputEle){
		resamplerSampleRate = +inputEle.value;
	}
	function setResampleBufferSize(inputEle){
		resamplerBufferSize = +inputEle.value;
	}
	function setResampleQuality(inputEle){
		resamplerQuality = +inputEle.value;
	}
	
	var waveEncoderLookback = 0;
	var waveEncoderRecordMax = 6000;
	var waveEncoderGate = document.getElementById('waveEncoderGateState');
	function waveEncoderSetGate(state){
		window.waveEncoder.handle.sendToModule({gate: state});
		//waveEncoderGate.textContent = state;
		waveEncoderGate.className = state;
	}
	function waveEncoderGetWave(){
		window.waveEncoder.handle.sendToModule({request: {get: "wave"}});
	}
	function waveEncoderGetBuffer(){
		window.waveEncoder.handle.sendToModule({request: {get: "buffer"}});
	}
	function setWaveEncoderLookback(ele){
		waveEncoderLookback = +ele.value;
	}
	function setWaveEncoderRecordMax(ele){
		waveEncoderRecordMax = +ele.value;
	}
	function waveEncoderMessage(data){
		console.error("wave-encoder", data);
		if (data.output && data.output.wav){
			addWaveToPage(data.output.wav);
			
		}else if (data.output && data.output.buffer){
			plotBufferToPage(data.output.buffer);
		}
		if (data.gate){
			waveEncoderGate.className = data.gate.isOpen? "open" : "close";
			if (data.gate.isOpen === false){
				//waveEncoderGetBuffer();		//TODO: this destroys the lookback buffer
				waveEncoderGetWave();
			}
		}
	}
	function addWaveToPage(wavAudio, targetEle){
		var audioEle = document.createElement("audio");
		audioEle.src = window.URL.createObjectURL(new Blob([wavAudio], { type: "audio/wav" }));
		audioEle.setAttribute("controls", "controls");
		var audioBox = document.createElement("div");
		audioBox.appendChild(audioEle);
		if (!targetEle) targetEle = document.getElementById("mainView") || document.body;
		targetEle.appendChild(audioBox);
	}
	function plotBufferToPage(buffer){
		var ele = addChartContainerToPage();
		var x = uPlot.lazy.createSequence(0, buffer.length);
		uPlot.lazy.plot({
			targetElement: ele,
			showPoints: false,
			strokeWidth: 1,
			data: [x, buffer]
		});
	}
	
	function setVolume1(data){
		//console.log(data);
		if (data.volume != undefined){
			plot1.addValues(data.volume);
			plot1.draw();
		}else{
			console.log(data);
		}
	}
	function setVolume2(data){
		//console.log(data.samples);
		if (data.rms != undefined){
			plot2.addValues(data.rms);
			plot2.draw();
		}else{
			console.log(data);
		}
	}
	function setVolume3(data){
		//console.log(data);
		if (data.volume != undefined){
			plot3.addValues(data.volume);
			plot3.draw();
		}else{
			console.log(data);
		}
	}
	
	function addChartContainerToPage(){
		var ele = document.createElement("div");
		ele.className = "chart";
		document.getElementById("mainView").appendChild(ele);
		return ele;
	}
	var plot1 = new uPlot.lazy.AutoSeries(document.getElementById('chart1'), 150, {
		rememberMax: true
	});
	var plot2 = new uPlot.lazy.AutoSeries(document.getElementById('chart2'), 150, {
		rememberMax: true
	}, {
		showAxisX: false
	});
	/*
	var plot3 = new uPlot.lazy.AutoSeries(document.getElementById('chart3'), 150, {
		rememberMax: true
	});
	*/
	uPlot.lazy.colorPalette[0] = "#ceff1a";		//default color for first line in graph
		
	function debugInfo(source, data){
		console.log(source, data);
	}
	
	function testBuffer(data){
		if (data.rms){
			setVolume2(data);
		}
		if (data.test){
			console.error("test", data.test);
			window.newBuff = data.test;
			if (data.sampleRate){
				SepiaFW.webAudio.encodeWaveBuffer(window.newBuff, data.sampleRate, data.channels || 1, true, function(r){
					addWaveToPage(r.wav);
					plotBufferToPage(data.test);
				});
			}
		}
	}
	function testResampler(obj, quality){
		if (!obj) obj = {};
		if (!quality) quality = 0;
		var smallBuff;
		var smallBuffRes;
		var testFile = "test-sounds/chatter_counting.wav";
		var testFileSampleRate = 24000;
		SepiaFW.webAudio.readFileAsBuffer(testFile, function(arrayBuffer){
			var buff = new Int16Array(arrayBuffer); //new Uint8Array(arrayBuffer);
			//var buff = new Int16Array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]);
			//buff = buff.map(function(num){ return (num / 17) * 32767; });
			buff = buff.slice(40000, 60000);
			//smallBuff = buff.slice(40000, 60000);
			smallBuff = buff;
			/*smallBuff = pcmConvert(buff, {
				channels: 1,
				interleaved: false,
				dtype: 'int16',
				endianness: 'le'
			}, {
				dtype: 'int8'
			});*/
			plotBufferToPage(smallBuff);
			SepiaFW.webAudio.resampleBufferWasm(smallBuff, testFileSampleRate, 16000, 1, quality, function(r){
				smallBuffRes = r.samples[0];
				/*smallBuffRes = pcmConvert(r.samples[0], {
					channels: 1,
					interleaved: false,
					dtype: 'uint8',
					endianness: 'le'
				}, {
					channels: 1,
					interleaved: false,
					dtype: 'float32',
					endianness: 'le'
				});*/
				plotBufferToPage(smallBuffRes);
				obj.a = smallBuff;
				obj.b = smallBuffRes;
			});
		}, console.error);
		return obj;
	}
</script>
</body>
</html>
