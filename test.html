<!doctype html>
<html lang="en-us">
<head>
	<meta charset="utf-8">
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SEPIA Web Audio Processor Test</title>

	<script src="src/visualization/uPlot.iife.min.js"></script>
	<script src="src/visualization/uPlot-lazy.min.js"></script>
	<script src="src/visualization/uPlot-lazy-heatmap.min.js"></script>
	<link rel="stylesheet" href="src/visualization/uPlot.min.css">

	<script src="src/polyfills/audioworklet-polyfill.js"></script>
	<script type="text/javascript" src="src/processor.js"></script>
	
	<script type="text/javascript" src="src/resources/pcm-convert.js"></script>
	<script type="text/javascript" src="src/resources/opus-file-splitter.js"></script>
	<script type="text/javascript" src="src/resources/fir-filter-resampler.js"></script>
	
	<style>
	* {
		box-sizing: border-box;
	}
	html, body {
		font-family: sans-serif;
		text-align: center;
	}
	#mainView > div {
		margin: 16px 8px;
	}
	button {
		display: inline-block;
		margin: 8px;
	}
	label, input {
		margin: 8px;
	}
	input.small {
		width: 72px;
	}
	select {
		min-height: 21px;
	}
	label + select,
	label + input {
		margin-left: 0;
	}
	.contorlGroup {
		display: flex;
		align-items: center;
		align-content: center;
		flex-wrap: wrap;
	}
	.contorlGroup.center {
		justify-content: center;
	}
	#mainView {
		display: inline-block;
		width: 100%;
		max-width: 1024px;
		text-align: center;
		padding: 16px; 
		margin:0;
	}
    #status {
		display: inline-block;
		width: 90px;
		height: 90px;
		background: #aaa;
		border-radius: 50%;
		margin: 8px;
    }
	#status.ready {
		background: #000;
	}
	#status.listening {
		background: #ff3355;
	}
	#status.voiceactivity {
		background: #16abc3;
	}
	#status.insequence {
		background: #33ee88;
	}
	#logMessages {
		max-height: 50vh;
		white-space: pre;
		text-align: left;
		overflow: auto;
		border: 1px solid currentColor;
		padding: 16px;
		overflow: auto;
		font-size: 15px;
	}
	.chart {
		margin: 30px 0;
		height: 128px;
		border: 1px solid #000;
		overflow: auto;
	}
	#volumeMeterNodeOutput {
		flex: 1 1 auto;
		min-width: 128px;
		border: 1px solid currentColor;
		margin: 8px;
	}
	#volumeMeterNodeOutput > div {
		margin: 0;
		padding: 0;
		height: 21px;
		width: 0%;
		background: #ff3355;
	}
	#waveEncoderGateState {
		width: 18px;
		height: 18px;
		background: #eee;
		border-radius: 9px;
	}
	#waveEncoderGateState.open {
		background: #0f5;
	}
	#waveEncoderGateState.close {
		background: #000;
		border-radius: 0;
	}
	#micDeviceId {
		max-width: 160px;
	}
	</style>
</head>
<body>
<div id="mainView">
	<h1>SEPIA Web Audio Processor</h1>
	<div id="info">Info: []</div>
	<div id="status"></div>
	<div>
		<button onclick="createRecorder(this);">Create</button>
		<button onclick="startRecording(this);">Start</button>
		<button onclick="stopRecording(this);">Stop</button>
		<button onclick="releaseRecorder(this);">Release</button>
	</div>
	<div id="inputSourceOptions" class="contorlGroup center">
		<label>Target Sample-Rate:</label><select id="sampleRateSelector">
			<option value="" selected>Auto</option>
			<option value="8000">8000</option>
			<option value="16000">16000</option>
			<option value="44000">44100</option>
			<option value="48000">48000</option>
			<option value="96000">96000</option>
		</select>
		<label>Audio Source:</label><select id="sourceTypeSelector" onchange="inputSourceChanged(this);">
			<option value="mic" selected>Microphone</option>
			<option value="whiteNoise">White-Noise Generator</option>
			<option value="file1">File Stream 1</option>
			<option value="file2">File Stream 2</option>
			<option value="legacySpMic">Legacy Script-Processor Mic</option>
		</select>
		<div id="micOptions" class="contorlGroup">
			<label><b>Mic Options</b></label>
			<label>deviceId (label):</label><select id="micDeviceId" onchange="setMicOption('deviceId', this.value);"><option value="" selected>Default</option></select>
			<label>sampleRate:</label><input id="micSampleRate" style="width: 54px;" value="48000" onchange="setMicOption('sampleRate', +this.value);">
			<label>channelCount:</label><input id="micChannelCount" style="width: 24px;" value="1" onchange="setMicOption('channelCount', +this.value);">
			<label>noiseSuppression:</label><input id="micNoiseSuppression" type="checkbox" checked onchange="setMicOption('noiseSuppression', this.checked);">
			<label>autoGainControl:</label><input id="micAutoGainControl" type="checkbox" checked onchange="setMicOption('autoGainControl', this.checked);">
			<label>echoCancellation:</label><input id="micEchoCancellation" type="checkbox" checked onchange="setMicOption('echoCancellation', this.checked);">
		</div>
	</div>
	<div id="logMessages">- Log -</div>
	<div id="volumeMeterControls" class="contorlGroup">
		<label><b>Volume-Processor</b></label>
		<label>Gain:</label><input id="volumeMeterGain" class="small" type="number" value="1.0" onchange="setVolumeGain(+this.value);">
		<label>FPS:</label><input id="volumeMeterFps" class="small" value="40" onchange="setVolumeProcFps(+this.value);">
		<label>Meter:</label><div id="volumeMeterNodeOutput"><div></div></div>
	</div>
	<div id="resamplerControls" class="contorlGroup">
		<label><b>Resampler (Speex WASM)</b></label>
		<label>Sample-Rate:</label><input id="resamplerSampleRate" class="small" value="16000" onchange="setResamplerSampleRate(this);" placeholder="16000">
		<label>Buffer-Size:</label><input id="resamplerBufferSize" class="small" value="512" onchange="setResamplerBufferSize(this);" placeholder="512">
		<label>Quality:</label><input id="resampleQuality" class="small" value="7" onchange="setResampleQuality(this);" placeholder="0-10 (0: fastest, 10: best)">
	</div>
	<div id="basicBufferControls" class="contorlGroup" style="display:none;">
		<label><b>Basic Buffer</b></label>
		<label>Buffer-Size:</label><input id="basicBufferSize" class="small" value="512" onchange="setResamplerBufferSize(this);" placeholder="512">
	</div>
	<div id="waveEncoderControls" class="contorlGroup">
		<label><b>Wave Encoder</b></label>
		<label>Lookback (ms):</label><input id="waveEncoderLookback" class="small" value="0" onchange="setWaveEncoderLookback(this);">
		<label>Record Max. (ms):</label><input id="waveEncoderRecordMax" class="small" value="6000" onchange="setWaveEncoderRecordMax(this);"><div style="flex: 1 0 100%;"></div>
		<label>Gate:</label><div id="waveEncoderGateState"></div><label></label>
		<label>Control:</label><button onclick="waveEncoderSetGate('open');">Capture</button><button onclick="waveEncoderSetGate('close');">Stop</button><label></label>
		<label>Export:</label><button onclick="waveEncoderGetWave();">Get Wave-File</button>
		<button onclick="waveEncoderGetBuffer();">Show Buffer</button>
	</div>
	<div id="mediaRecorderControls" class="contorlGroup" style="display:none;">
		<label><b>Media Recorder</b></label>
		<label>Codec/format:</label><select id="mediaRecorderCodec"><option value="" selected>Default</option></select>
		<label>Realtime Decoding:</label><input id="mediaRecorderDecode" type="checkbox">
		<label>Record Max. (ms):</label><input id="mediaRecorderRecordMax" class="small" value="6000"><div style="flex: 1 0 100%;"></div>
		<label>Control:</label><button onclick="startMediaRecorder();">Capture</button><button onclick="stopMediaRecorder();">Stop</button>
		<label>Export:</label><button onclick="getRawDataFromMediaRecorder();">Show Decoded Data</button>
	</div>
	<div class="contorlGroup">
		<label><b>Switches:</b></label>
		<label>Use volume-proc.:</label><input type="checkbox" id="useVolumeProcessor" checked onchange="useVolumeProcessor(this.checked);">
		<label>Use resampler:</label><input type="checkbox" id="useResampler" checked onchange="useResampler(this.checked);">
		<label>Use wave-encoder:</label><input type="checkbox" id="useWaveEncoder" checked onchange="useWaveEncoder(this.checked);">
		<label>Plot 1:</label><input type="checkbox" id="usePlot1" checked onchange="usePlot(1, this);">
		<label>Plot 2:</label><input type="checkbox" id="usePlot2" checked onchange="usePlot(2, this);">
	</div>
	<div id="chart1" class="chart"></div>
	<div id="chart2" class="chart"></div>
	<!--<div id="chart3" class="chart"></div>-->
</div>
<script type='text/javascript'>
	var infoElement = document.getElementById('info');
	var statusElement = document.getElementById('status');
	var targetSampleRateSelector = document.getElementById("sampleRateSelector");
	targetSampleRateSelector.onchange = function(){
		targetSampleRate = +targetSampleRateSelector.value;
	};
	var sourceSelector = document.getElementById("sourceTypeSelector");
	var logElement = document.getElementById('logMessages');
	
	function showLogMessage(msg, data){
		var info = (typeof data == "object")? (data.name && data.message? (data.name + " - " + data.message) : JSON.stringify(data)) : data;
		logElement.textContent += "\n" + (new Date().toLocaleTimeString()) + " - " + (msg + " - " + info);
		logElement.scrollTo(0, logElement.scrollHeight);
	}
	
	//callbacks:
	
	function onProcessorReady(info){
		statusElement.className = "ready";
		showLogMessage("onReady", info);
		if (info.sourceInfo.label) showLogMessage("onReady details: sourceInfo.label", info.sourceInfo.label);
		if (info.sourceInfo.settings) showLogMessage("onReady details: sourceInfo.settings", info.sourceInfo.settings);
		infoElement.textContent = "Info: " 
			+ "Input Sample-Rate=" + info.inputSampleRate
			+ " - Source-Type=" + info.sourceInfo.type;
		console.log("onReady", info);
		
		//for testing:
		if (!doUseWaveEncoder && rec.source.mediaStream) createMediaRecorder(rec.source.mediaStream, info.sourceInfo);
		else document.getElementById("mediaRecorderControls").style.display = "none";
	}
	
	function onProcessorInitError(err){
		statusElement.className = "";
		showLogMessage("ERROR - onInitError", err);
		console.error("onInitError", err);
	}
	
	function onAudioStart(info){
		statusElement.className = "listening"; 
		showLogMessage("onaudiostart", info);
		console.log("onaudiostart", info);
	}
	
	function onAudioEnd(info){
		statusElement.className = "ready";
		showLogMessage("onaudioend", info);
		console.log("onaudioend", info);
	}
	
	function onProcessorRelease(info){
		statusElement.className = "";
		showLogMessage("onrelease", info);
		console.log("onrelease", info);
	}
	
	function onProcessorError(err){
		statusElement.className = "";
		showLogMessage("ERROR - Processor - onerror", err);
		console.error("onerror", err);
	}
	
	function onDebugLog(msg){
		console.log("debugLog", msg);
	}
	
	//main:

	var rec;
	var targetSampleRate = +targetSampleRateSelector.value;		//e.g. 16000
	var isLegacyScriptProcessor;
	
	//set correct modules folder
	SepiaFW.webAudio.defaultProcessorOptions.moduleFolder = "src/modules";
	
	async function createRecorder(btn){
		//audio source
		var useWhiteNoiseTest = false; //document.getElementById("useWhiteNoiseRecorder").checked;
		var customSource = undefined;
		var audioSource = sourceSelector.value;
		if (audioSource == "whiteNoise"){
			//customSourceNode: white-noise
			useWhiteNoiseTest = true;
		}else if (audioSource.indexOf("file") == 0){
			//customSourceNode: file audio buffer
			try {
				customSource = await createFileSource(audioSource);
			}catch (err){
				onProcessorInitError(err);
				return;
			}
		}else if (audioSource == "legacySpMic"){
			//customSourceNode: legacy script processor (with mic source)
			try {
				customSource = await SepiaFW.webAudio.createLegacyMicrophoneScriptProcessor({
					targetSampleRate: targetSampleRate,
					bufferSize: resamplerBufferSize
				});
				isLegacyScriptProcessor = true;
			}catch (err){
				onProcessorInitError(err);
				return;
			}
		}else{
			//default: mic
		}
		
		//create processor modules
		var volumeProcessor = {
			name: 'volume-processor',
			settings: {
				onmessage: setVolume1,		//info: 'onmessage' has the parameters: 'data' and 'processNodes'
				options: {
					//use AudioWorklet options directly or common "setup" field for worklet and workers:
					processorOptions: {
						gain: volGain,		//e.g 2.0
						fps: volProcFps		//e.g 25
					}
				}
			}
		};
		window.volumeProcessor = volumeProcessor;
		
		var resampler = {
			name: 'speex-resample-switch', //'buffer-switch',
			settings: {
				onmessage: testBuffer,
				sendToModules: (doUseWaveEncoder? [3] : []),	//index as given to processor - 0: source, 1: volume-meter, 2: speex-resample-switch, 3: wave-encoder
				options: {
					processorOptions: {
						targetSampleRate: resamplerSampleRate, 	//16000,
						resampleQuality: resamplerQuality, 		//7,
						bufferSize: resamplerBufferSize, 		//512,
						passThroughMode: 1,		//0: none, 1: original (float32), 2: 16Bit PCM - NOTE: NOT resampled
						calculateRmsVolume: true
					}
				}
			}
		};
		var resamplerWorker = {
			name: 'speex-resample-worker',
			type: 'worker',
			settings: {
				onmessage: testBuffer,
				sendToModules: (doUseWaveEncoder? [2] : []),	//index as given to processor - 0: source, 1: volume-meter, 2: speex-resample-switch, 3: wave-encoder
				options: {
					setup: {
						inputSampleSize: resamplerBufferSize,	//output bufferSize of previous module
						targetSampleRate: resamplerSampleRate, 	//16000,
						resampleQuality: resamplerQuality, 		//7,
						bufferSize: resamplerBufferSize, 		//512,		//TODO: set correct value (or replace with ratio?)
						calculateRmsVolume: true,
						gain: volGain		//TODO: keep?
					}
				}
			}
		};
		var bufferSwitch = {
			name: 'buffer-switch',
			settings: {
				onmessage: testBuffer,
				sendToModules: (doUseWaveEncoder? [3] : []),	//index as given to processor - 0: source, 1: volume-meter, 2: speex-resample-switch, 3: wave-encoder
				options: {
					processorOptions: {
						bufferSize: resamplerBufferSize, 		//512,
						passThroughMode: 1,		//0: none, 1: original (float32)
					}
				}
			}
		};
		
		var waveEncoder = {
			name: 'wave-encoder',
			type: 'worker',
			handle: {},		//will be updated on init. with ref. to node.
			settings: {
				onmessage: waveEncoderMessage,
				options: {
					setup: {
						inputSampleRate: (doUseResampler? resamplerSampleRate : 0),	//output sampleRate of previous module, if undefined take targetSampleRate
						inputSampleSize: resamplerBufferSize,	//output bufferSize of previous module
						lookbackBufferMs: waveEncoderLookback,
						//recordBufferLimitKb: 600,
						recordBufferLimitMs: waveEncoderRecordMax
					}
				}
			}
		};
		window.waveEncoder = waveEncoder;
		
		//put together modules
		var activeModules = [];
		if (doUseVolumeProcessor){
			activeModules.push(volumeProcessor);
		}
		if (doUseResampler && !isLegacyScriptProcessor){
			activeModules.push(resampler);
		}else if (doUseResampler && isLegacyScriptProcessor){
			activeModules.push(resamplerWorker);
		}else if (!isLegacyScriptProcessor){
			activeModules.push(bufferSwitch);
		}
		if (doUseWaveEncoder){
			activeModules.push(waveEncoder);
		}
				
		//create processor
		rec = new SepiaFW.webAudio.Processor({
			onaudiostart: onAudioStart,
			onaudioend: onAudioEnd,
			onrelease: onProcessorRelease,
			onerror: onProcessorError,
			targetSampleRate: targetSampleRate,
			//targetBufferSize: 512,
			modules: activeModules,
			destinationNode: undefined,		//defaults to: audioContext.destination
			startSuspended: true,
			debugLog: onDebugLog,
			customSourceTest: useWhiteNoiseTest,
			customSource: customSource
			
		}, function(msg){
			//Init. ready
			onProcessorReady(msg);
			
		}, function(err){
			//Init. error
			onProcessorInitError(err);
		});
	}
	
	function startRecording(btn){
		if (rec){
			rec.start();
		}
	}
	
	function stopRecording(btn){
		if (rec){
			rec.stop();
			//UI specific:
			setVolumeBar({volume: 0.0});
		}
	}
	
	function releaseRecorder(btn){
		if (rec){
			rec.release();
		}
	}
	
	//Input source options
	
	var micAudioConstraintOptionElements = {
		deviceId: '<label>deviceId (label):</label><select id="micDeviceId" onchange="setMicOption(\'deviceId\', this.value);"><option value="" selected>Default</option></select>',
		//sampleRate: '<label>sampleRate:</label><input id="micSampleRate" style="width: 54px;" value="48000" onchange="setMicOption(\'sampleRate\', +this.value);">',
		channelCount: '<label>channelCount:</label><input id="micChannelCount" style="width: 24px;" value="1" onchange="setMicOption(\'channelCount\', +this.value);">',
		noiseSuppression: '<label>noiseSuppression:</label><input id="micNoiseSuppression" type="checkbox" checked onchange="setMicOption(\'noiseSuppression\', this.checked);">',
		autoGainControl: '<label>autoGainControl:</label><input id="micAutoGainControl" type="checkbox" onchange="setMicOption(\'autoGainControl\', this.checked);">',
		echoCancellation: '<label>echoCancellation:</label><input id="micEchoCancellation" type="checkbox" onchange="setMicOption(\'echoCancellation\', this.checked);">'
	};
	(function(){
		var micO = document.getElementById("micOptions");
		micO.innerHTML = "";
		var sac = SepiaFW.webAudio.getSupportedAudioConstraints();
		Object.keys(sac).forEach(function(aco, i){
			var oEle = micAudioConstraintOptionElements[aco];
			if (oEle){
				micO.innerHTML += oEle;
			}else{
				console.log("Skipped mic constraint option: " + aco);
			}
		});
		var devSel = document.getElementById("micDeviceId");
		devSel.innerHTML = '<option value="" selected>Default</option>';
		SepiaFW.webAudio.getAudioDevices().then(function(devices){
			window.audioInputDevicesFound = devices.input;
			Object.keys(devices.input).forEach(function(label, i){
				var deviceId = devices.input[label];
				var opt = document.createElement("option");
				opt.textContent = label;
				opt.value = deviceId;
				devSel.appendChild(opt);
			});
		}).catch(function(err){
			console.error("Error in 'getAudioDevices'", err);
			var opt = document.createElement("option");
			opt.textContent = "ERROR";
			opt.value = "";
			devSel.appendChild(opt);
		});
	})();
	
	function inputSourceChanged(ele){
		if (!ele) ele = sourceSelector;
		if (ele.value == "mic" || ele.value == "legacySpMic"){
			document.getElementById("micOptions").style.display = "";
		}else{
			document.getElementById("micOptions").style.display = "none";
		}
	}
	inputSourceChanged();
	function setMicOption(optionName, value){
		//This is the 'brute-force' method to set microphone constraints ... but they are not yet accessible via options
		console.log("Set mic constraint option", optionName, value);
		SepiaFW.webAudio.overwriteSupportedAudioConstraints[optionName] = value;
	}
	
	//Custom audio nodes
	
	async function createFileSource(fileId){
		var fileUrl;
		if (fileId == "file2"){
			fileUrl = "test-sounds/chatter_counting.ogg";
		}else{
			fileUrl = "test-sounds/traffic_counting.ogg";
		}
		showLogMessage("createFileSource", fileUrl); 
		return SepiaFW.webAudio.createFileSource(fileUrl, {
			targetSampleRate: targetSampleRate
		});
	}
	
	//Audio node data/visualizations:
	
	var doUseVolumeProcessor = document.getElementById("useVolumeProcessor").checked;
	var volMeterOutBar = document.getElementById('volumeMeterNodeOutput').firstChild;
	var volGain = +document.getElementById('volumeMeterGain').value;
	var volProcFps = +document.getElementById('volumeMeterFps').value;
	//var volSmooth = 0.8;	//0=none, 1=max
	function setVolumeGain(val){
		volGain = val;
		if (window.volumeProcessor && volumeProcessor.handle){
			volumeProcessor.handle.sendToModule({gain: {set: val}});
		}
	}
	function setVolumeProcFps(val){
		volProcFps = val;
		if (window.volumeProcessor && volumeProcessor.handle){
			volumeProcessor.handle.sendToModule({fps: {set: val}});
		}
	}
	function setVolumeBar(vol){
		//console.log("volume-bar data", data);
		var volPercent = Math.min(100, Math.round(vol * 100));
		volMeterOutBar.style.width = (volPercent + "%");
	}
	function useVolumeProcessor(useIt){
		doUseVolumeProcessor = useIt;
		if (useIt){
			document.getElementById("volumeMeterControls").style.display = "";
		}else{
			document.getElementById("volumeMeterControls").style.display = "none";
		}
	}
	
	var doUseResampler = document.getElementById("useResampler").checked;
	var resamplerSampleRate = +document.getElementById("resamplerSampleRate").value; 	//e.g. 16000;
	var resamplerBufferSize = +document.getElementById("resamplerBufferSize").value; 	//e.g. 512;
	var resamplerQuality = +document.getElementById("resampleQuality").value; 			//e.g. 7;
	function setResamplerSampleRate(inputEle){
		resamplerSampleRate = +inputEle.value;
	}
	function setResamplerBufferSize(inputEle){
		resamplerBufferSize = +inputEle.value;
		//kind of clumsy way to use this variable and function for both settings
		if (doUseResampler){
			document.getElementById("basicBufferSize").value = resamplerBufferSize;
		}else{
			document.getElementById("resamplerBufferSize").value = resamplerBufferSize;
		}
	}
	function setResampleQuality(inputEle){
		resamplerQuality = +inputEle.value;
	}
	function useResampler(useIt){
		doUseResampler = useIt;
		if (useIt){
			document.getElementById("resamplerControls").style.display = "";
			document.getElementById("basicBufferControls").style.display = "none";
		}else{
			document.getElementById("resamplerControls").style.display = "none";
			document.getElementById("basicBufferControls").style.display = "";
		}
	}
	
	var doUseWaveEncoder = document.getElementById("useWaveEncoder").checked;
	var waveEncoderLookback = +document.getElementById("waveEncoderLookback").value; 	//e.g. 0;
	var waveEncoderRecordMax = +document.getElementById("waveEncoderRecordMax").value; 	//e.g. 6000;
	var waveEncoderGate = document.getElementById('waveEncoderGateState');
	function waveEncoderSetGate(state){
		window.waveEncoder.handle.sendToModule({gate: state});
		//waveEncoderGate.textContent = state;
		waveEncoderGate.className = state;
	}
	function waveEncoderGetWave(){
		window.waveEncoder.handle.sendToModule({request: {get: "wave"}});
	}
	function waveEncoderGetBuffer(){
		window.waveEncoder.handle.sendToModule({request: {get: "buffer"}});
	}
	function setWaveEncoderLookback(ele){
		waveEncoderLookback = +ele.value;
	}
	function setWaveEncoderRecordMax(ele){
		waveEncoderRecordMax = +ele.value;
	}
	function waveEncoderMessage(data){
		console.error("wave-encoder", data);
		if (data.output && data.output.wav){
			addWaveToPage(data.output.wav);
			if (data.output.wav.byteLength){
				var byteLen = data.output.wav.byteLength;
				var samplesLen = data.output.totalSamples;
				var time = Math.round(samplesLen/data.output.sampleRate*1000);
				showLogMessage("waveEncoder", "created wave file - byteLength: " + byteLen + ", samples: " + samplesLen + ", time calc.: " + time);
			}else{
				showLogMessage("waveEncoder", "created wave file");
			}
			
		}else if (data.output && data.output.buffer){
			plotData(data.output.buffer);
			showLogMessage("waveEncoder", "buffer output length: " + data.output.buffer.length);
		}
		if (data.gate){
			waveEncoderGate.className = data.gate.isOpen? "open" : "close";
			if (data.gate.isOpen === false){
				//waveEncoderGetBuffer();		//TODO: this destroys the lookback buffer
				waveEncoderGetWave();
				if (data.gate.closedAt){
					showLogMessage("waveEncoder", "gate closed - time open (ms): " + (data.gate.closedAt - data.gate.openedAt));
				}else{
					showLogMessage("waveEncoder", "gate closed");
				}
			}
		}
	}
	function addWaveToPage(wavAudio, targetEle){
		var audioEle = document.createElement("audio");
		audioEle.src = window.URL.createObjectURL((wavAudio.constructor.name == "Blob")? wavAudio : (new Blob([wavAudio], { type: "audio/wav" })));
		audioEle.setAttribute("controls", "controls");
		var audioBox = document.createElement("div");
		audioBox.appendChild(audioEle);
		if (!targetEle) targetEle = document.getElementById("mainView") || document.body;
		targetEle.appendChild(audioBox);
	}
	function useWaveEncoder(useIt){
		doUseWaveEncoder = useIt;
		if (useIt){
			document.getElementById("waveEncoderControls").style.display = "";
			document.getElementById("mediaRecorderControls").style.display = "none";
		}else{
			document.getElementById("waveEncoderControls").style.display = "none";
			document.getElementById("mediaRecorderControls").style.display = "";
			showMediaRecorderCodecs();
		}
	}
	
	var fixedPlots = {
		1: {
			graph: (new uPlot.lazy.AutoSeries(document.getElementById('chart1'), 150, {
				rememberMax: true
			})), 
			use: document.getElementById("usePlot1").checked
		},
		2: {
			graph: (new uPlot.lazy.AutoSeries(document.getElementById('chart2'), 150, {
				rememberMax: true
			}, {
				showAxisX: false
			})),
			use: document.getElementById("usePlot2").checked
		}
	}
	function addChartContainerToPage(){
		var ele = document.createElement("div");
		ele.className = "chart";
		document.getElementById("mainView").appendChild(ele);
		return ele;
	}
	function plotData(data, plotIndex){
		var p = fixedPlots[plotIndex];
		if (p){
			if (p.use){
				p.graph.addValues(data);
				p.graph.draw();
			}
		}else{
			var ele = addChartContainerToPage();
			var x = uPlot.lazy.createSequence(0, data.length);
			uPlot.lazy.plot({
				targetElement: ele,
				showPoints: false,
				strokeWidth: 1,
				data: [x, data]
			});
		}
	}
	function usePlot(index, ele){
		var p = fixedPlots[index];
		if (p){
			p.use = ele.checked;
			var container = document.getElementById("chart" + index);
			if (container) container.style.display = p.use? "" : "none";
		}
	}
	uPlot.lazy.colorPalette[0] = "#ceff1a";		//default color for first line in graph
		
	function setVolume1(data){
		//console.log(data);
		if (data.rms != undefined){
			plotData(data.rms, 1);
			if (data.avg) setVolumeBar(data.avg);
		}else{
			console.log(data);
		}
	}
	function setVolume2(data){
		//console.log(data.samples);
		if (data.rms != undefined){
			plotData(data.rms, 2);
		}else{
			console.log(data);
		}
	}
	function debugInfo(source, data){
		console.log(source, data);
	}
	
	function testBuffer(data){
		if (data.rms){
			setVolume2(data);
		}
		if (data.test){
			console.error("test", data.test);
			window.newBuff = data.test;
			if (data.sampleRate){
				SepiaFW.webAudio.encodeWaveBuffer(window.newBuff, data.sampleRate, data.channels || 1, true, function(r){
					addWaveToPage(r.wav);
					plotData(data.test);
				});
			}
		}
	}
	
	function showMediaRecorderCodecs(){
		//add codec options
		var codecSel = document.getElementById("mediaRecorderCodec");
		codecSel.innerHTML = '<option value="" selected>Default</option>';
		var selectedCodec = "";
		var supportedCodecs = SepiaFW.webAudio.getSupportedMediaRecorderCodecs();
		Object.keys(supportedCodecs).forEach(function(codec){
			console.log("MediaRecorder codec:", codec, supportedCodecs[codec]);
			var opt = document.createElement("option");
			opt.textContent = codec;
			opt.value = codec;
			codecSel.appendChild(opt);
			if (!selectedCodec) selectedCodec = codec;
		});
		codecSel.value = selectedCodec;
	}
	function createMediaRecorder(stream, sourceInfo){
		//create
		mediaRecorderChunks = [];
		mediaRecorderSourceInfo = sourceInfo;
		var mimeType;
		var decodeToAudioBuffer = document.getElementById("mediaRecorderDecode").checked;
		if (decodeToAudioBuffer){
			showLogMessage("mediaRecorderWarning", "This recorder does not yet support decoding of chunks.");
		}
		var recordLimitMs = +document.getElementById("mediaRecorderRecordMax").value;
		var codec = document.getElementById("mediaRecorderCodec").value;
		console.log("AudioRecorder selected codec", codec);
		var recorderOptions = {
			codec: codec,
			decodeToAudioBuffer: decodeToAudioBuffer,
			recordLimitMs: recordLimitMs,
			chunkSize: 2048,
			onerror: function(err){ showLogMessage("mediaRecorderError", err); },
			onstart: function(e){ showLogMessage("mediaRecorderStart", {}); },
			onpause: function(e){ showLogMessage("mediaRecorderPause", {}); },
			onresume: function(e){ showLogMessage("mediaRecorderResume", {}); },
			onstop: function(e){
				console.error("onstop");		//DEBUG
				showLogMessage("mediaRecorderStop", {message: "Recorder stopped", chunkSize: mediaRecorderChunks.length});
				if (decodeToAudioBuffer){
					if (mediaRecorderChunks.length) plotData(...mediaRecorderChunks);
				}else{
					var blob = new Blob(mediaRecorderChunks, {'type' : mimeType});
					addWaveToPage(blob);
				}
			},
			ondataavailable: function(e){
				if (e && e.data){
					console.error("ondataavailable");		//DEBUG
					mediaRecorderChunks.push(e.data);
					//e.decodeTime
				}
			}
		};
		SepiaFW.webAudio.createAudioRecorder(stream, mediaRecorderSourceInfo, recorderOptions).then(function(res){
			mimeType = res.mimeType;
			showLogMessage("mediaRecorderCreated", "MIME-Type: " + res.mimeType + ", sample-time: " + res.sampleTime);
			window.audioRecorder = res;
			document.getElementById("mediaRecorderControls").style.display = "";
			
		}).catch(function(err){
			showLogMessage("mediaRecorderError", err);
			document.getElementById("mediaRecorderControls").style.display = "none";
		});
	}
	function startMediaRecorder(){
		mediaRecorderChunks = [];
		window.audioRecorder.start();
	}
	function stopMediaRecorder(){
		window.audioRecorder.stop();
	}
	function getRawDataFromMediaRecorder(){
		if (mediaRecorderChunks.length){
			var start = Date.now();
			//console.log("mediaRecorderSourceInfo", mediaRecorderSourceInfo);
			function callback(audioBuffer){
				console.log("decode time: " + (Date.now() - start));
				var channelData = audioBuffer.getChannelData(0);
				plotData(channelData);
				console.log("decode+plot time: " + (Date.now() - start));
			}
			var sampleRate = mediaRecorderSourceInfo.settings.sampleRate;
			var channels = mediaRecorderSourceInfo.settings.channelCount;
			SepiaFW.webAudio.offlineAudioContextBlobDecoder(sampleRate, channels, new Blob(mediaRecorderChunks, {type: window.audioRecorder.mimeType}), callback);
		}
	}
	var mediaRecorderChunks = [];
	var mediaRecorderSourceInfo;
	
	//-----------------------------------------------------
	
	function testResampler(obj, quality){
		if (!obj) obj = {};
		if (!quality) quality = 0;
		var smallBuff;
		var smallBuffRes;
		var testFile = "test-sounds/chatter_counting.wav";
		var testFileSampleRate = 24000;
		SepiaFW.webAudio.readFileAsBuffer(testFile, function(arrayBuffer){
			var buff = new Int16Array(arrayBuffer); //new Uint8Array(arrayBuffer);
			//var buff = new Int16Array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]);
			//buff = buff.map(function(num){ return (num / 17) * 32767; });
			buff = buff.slice(40000, 60000);
			//smallBuff = buff.slice(40000, 60000);
			smallBuff = buff;
			/*smallBuff = pcmConvert(buff, {
				channels: 1,
				interleaved: false,
				dtype: 'int16',
				endianness: 'le'
			}, {
				dtype: 'int8'
			});*/
			plotData(smallBuff);
			SepiaFW.webAudio.resampleBufferViaSpeex(smallBuff, testFileSampleRate, 16000, 1, quality, function(r){
				smallBuffRes = r.samples[0];
				/*smallBuffRes = pcmConvert(r.samples[0], {
					channels: 1,
					interleaved: false,
					dtype: 'uint8',
					endianness: 'le'
				}, {
					channels: 1,
					interleaved: false,
					dtype: 'float32',
					endianness: 'le'
				});*/
				plotData(smallBuffRes);
				obj.a = smallBuff;
				obj.b = smallBuffRes;
			});
		}, console.error);
		return obj;
	}
	function testResampler2(){
		//FirFilterResampler
		var buff = new Float32Array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]);
		buff = [...buff, ...buff, ...buff];
		buff = buff.map(function(num){ return (num - 9)/17; });
		plotData(buff);
		
		var resampler = new FirFilterResampler().getProcessor(48000, 16000, 127);
		console.log("filterArray", resampler.filterArray);
		if (resampler.filterArray) plotData(resampler.filterArray);
		
		var buffRes = resampler.process(buff);
			
		plotData(buffRes);
		return {a: buff, b: buffRes};
	}
</script>
</body>
</html>
