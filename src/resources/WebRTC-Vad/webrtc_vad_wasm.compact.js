var webRtcVadWasmBinaryFile = "data:application/octet-stream;base64,AGFzbQEAAAABpAEVYAN/f38Bf2AAAGABfwF/YAJ/fwF/YAd/f39/f39/AX9gCH9/f39/f39/AX9gA39+fwF+YAF/AGAHf39/f39/fwBgBH9/f38AYAABf2ACf38AYAZ/f39/f38Bf2AEf39/fwF/YAZ/f39/f38AYAV/f39/fwBgA39/fwBgCX9/f39/f39/fwF/YAR/f35/AX5gCH9/f39/f39/AGAFf39/f38BfwLWAhADZW52BWFib3J0AAcDZW52Dl9fX2Fzc2VydF9mYWlsAAkDZW52C19fX3NldEVyck5vAAcDZW52DV9fX3N5c2NhbGwxNDAAAwNlbnYNX19fc3lzY2FsbDE0NgADA2VudgxfX19zeXNjYWxsNTQAAwNlbnYLX19fc3lzY2FsbDYAAwNlbnYZX2Vtc2NyaXB0ZW5fZ2V0X2hlYXBfc2l6ZQAKA2VudhZfZW1zY3JpcHRlbl9tZW1jcHlfYmlnAAADZW52F19lbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwAAIDZW52F2Fib3J0T25DYW5ub3RHcm93TWVtb3J5AAIDZW52C3NldFRlbXBSZXQwAAcDZW52DF9fdGFibGVfYmFzZQN/AANlbnYORFlOQU1JQ1RPUF9QVFIDfwADZW52Bm1lbW9yeQIBgAKAAgNlbnYFdGFibGUBcAEgIANnZgIKBwsKAgwCAgMNAwIDAAANAgAAAA0ODwkCDw0JAAEBAQEDCQcAEAkJCQQCBwAAAAIFAgAACAsDAwMDAwMCAAYCCgIAAgcAAgIDDQMCAgcDAAACAwANBRESBwsTAgMABAUGAQcIFAYPAn8BQcA5C38BQcC5wAILB7ACFhFfX19lcnJub19sb2NhdGlvbgBNBV9mcmVlAFoFX21haW4AEAdfbWFsbG9jAFkHX21lbWNweQBcB19tZW1zZXQAXQ1fcHJvY2Vzc19kYXRhABIFX3NicmsAXghfc2V0bW9kZQARCmR5bkNhbGxfaWkAXwtkeW5DYWxsX2lpaQBgDGR5bkNhbGxfaWlpaQBhEGR5bkNhbGxfaWlpaWlpaWkAYhFkeW5DYWxsX2lpaWlpaWlpaQBjDGR5bkNhbGxfamlqaQBxCWR5bkNhbGxfdgBlCmR5bkNhbGxfdmkAZhBkeW5DYWxsX3ZpaWlpaWlpAGcTZXN0YWJsaXNoU3Rh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dUgbIQIgA0EBaiIDIAFHDQALIAILTgEDfyAAQQBHIAFBAEpxRQRAQf////8HDwtBACEDQf////8HIQIDQCADQQJ0IABqKAIAIgQgAiAEIAJIGyECIANBAWoiAyABRw0ACyACCy4BAX8jAiEBIwJBEGokAiABIABBPGooAgAQTjYCAEEGIAEQBhBMIQAgASQCIAALmAMBC38jAiEHIwJBMGokAiAHQSBqIQUgByIDIABBHGoiCigCACIENgIAIANBBGogAEEUaiILKAIAIARrIgQ2AgAgA0EIaiABNgIAIANBDGogAjYCACADQRBqIgEgAEE8aiIMKAIANgIAIAFBBGogAzYCACABQQhqQQI2AgACQAJAIAIgBGoiBEGSASABEAQQTCIBRg0AQQIhCANAIAFBAE4EQCADQQhqIAMgASADQQRqKAIAIglLIgYbIgMgASAJQQAgBhtrIgkgAygCAGo2AgAgA0EEaiINIA0oAgAgCWs2AgAgBSAMKAIANgIAIAVBBGogAzYCACAFQQhqIAZBH3RBH3UgCGoiCDYCAEGSASAFEAQQTCIGIAQgAWsiBEYNAiAGIQEMAQsLIABBEGpBADYCACAKQQA2AgAgC0EANgIAIAAgACgCAEEgcjYCACAIQQJGBH9BAAUgAiADQQRqKAIAawshAgwBCyAAQRBqIABBLGooAgAiASAAQTBqKAIAajYCACAKIAE2AgAgCyABNgIACyAHJAIgAgt0AQJ/IwIhBCMCQSBqJAIgBEEIaiIDIABBPGooAgA2AgAgA0EEaiABQiCIPgIAIANBCGogAT4CACADQQxqIAQiADYCACADQRBqIAI2AgBBjAEgAxADEExBAEgEfiAAQn83AwBCfwUgACkDAAshASAEJAIgAQsbACAAQYBgSwRAEE1BACAAazYCAEF/IQALIAALBQBB+CsLBAAgAAt2AQN/IwIhBCMCQSBqJAIgBCIDQRBqIQUgAEEkakEENgIAIAAoAgBBwABxRQRAIAMgAEE8aigCADYCACADQQRqQZOoATYCACADQQhqIAU2AgBBNiADEAUEQCAAQcsAakF/OgAACwsgACABIAIQSiEAIAQkAiAACwQAQQELAwABC4UCAQR/AkACQCACQRBqIgQoAgAiAw0AIAIQUwR/QQAFIAQoAgAhAwwBCyECDAELIAJBFGoiBigCACIFIQQgAyAFayABSQRAIAJBJGooAgAhAyACIAAgASADQQdxQQxqEQAAIQIMAQsgAUUgAkHLAGosAABBAEhyBH9BAAUCfyABIQMDQCAAIANBf2oiBWosAABBCkcEQCAFBEAgBSEDDAIFQQAMAwsACwsgAkEkaigCACEEIAIgACADIARBB3FBDGoRAAAiAiADSQ0CIAYoAgAhBCABIANrIQEgACADaiEAIAMLCyECIAQgACABEFwaIAYgBigCACABajYCACABIAJqIQILIAILfgECfyAAQcoAaiICLAAAIQEgAiABIAFB/wFqcjoAACAAKAIAIgFBCHEEfyAAIAFBIHI2AgBBfwUgAEEIakEANgIAIABBBGpBADYCACAAQRxqIABBLGooAgAiATYCACAAQRRqIAE2AgAgAEEQaiABIABBMGooAgBqNgIAQQALC44BAQN/AkACQCAAIgJBA3FFDQAgAiEBA0ACQCAALAAARQRAIAEhAAwBCyAAQQFqIgAiAUEDcQ0BDAILCwwBCwNAIABBBGohASAAKAIAIgNBgIGChHhxQYCBgoR4cyADQf/9+3dqcUUEQCABIQAMAQsLIANB/wFxBEADQCAAQQFqIgAsAAANAAsLCyAAIAJrCxsBAX8gABBUIgIgAEEBIAIgARBWR0EfdEEfdQtaAQJ/IAEgAmwhBCACQQAgARshAiADQcwAaigCAEF/SgRAIAMQUEUhBSAAIAQgAxBSIQAgBUUEQCADEFELBSAAIAQgAxBSIQALIAAgBEcEQCAAIAFuIQILIAILtAEBBn8jAiEDIwJBEGokAiADIgQgAUH/AXEiBzoAAAJAAkAgAEEQaiICKAIAIgUNACAAEFMEf0F/BSACKAIAIQUMAQshAQwBCyAAQRRqIgIoAgAiBiAFSQRAIAFB/wFxIgEgAEHLAGosAABHBEAgAiAGQQFqNgIAIAYgBzoAAAwCCwsgAEEkaigCACEBIAAgBEEBIAFBB3FBDGoRAABBAUYEfyAELQAABUF/CyEBCyADJAIgAQuGAQEDf0GQICgCACIBQcwAaigCAEF/SgR/IAEQUAVBAAshAiAAIAEQVUEASAR/QX8FAn8gAUHLAGosAABBCkcEQCABQRRqIgMoAgAiACABQRBqKAIASQRAIAMgAEEBajYCACAAQQo6AABBAAwCCwsgAUEKEFdBH3ULCyEAIAIEQCABEFELIAAL4TgBDH8jAiEKIwJBEGokAiAKIQkgAEH1AUkEf0H8KygCACIDQRAgAEELakF4cSAAQQtJGyICQQN2IgB2IgFBA3EEQCABQQFxQQFzIABqIgBBA3RBpCxqIgFBCGoiBigCACICQQhqIgUoAgAiBCABRgRAQfwrIANBASAAdEF/c3E2AgAFIARBDGogATYCACAGIAQ2AgALIAJBBGogAEEDdCIAQQNyNgIAIAAgAmpBBGoiACAAKAIAQQFyNgIAIAokAiAFDwsgAkGELCgCACIHSwR/IAEEQEECIAB0IgRBACAEa3IgASAAdHEiAEEAIABrcUF/aiIAQQx2QRBxIgEgACABdiIAQQV2QQhxIgFyIAAgAXYiAEECdkEEcSIBciAAIAF2IgBBAXZBAnEiAXIgACABdiIAQQF2QQFxIgFyIAAgAXZqIgRBA3RBpCxqIgBBCGoiBSgCACIBQQhqIggoAgAiBiAARgRAQfwrIANBASAEdEF/c3EiADYCAAUgBkEMaiAANgIAIAUgBjYCACADIQALIAFBBGogAkEDcjYCACABIAJqIgZBBGogBEEDdCIEIAJrIgNBAXI2AgAgASAEaiADNgIAIAcEQEGQLCgCACECIAdBA3YiBEEDdEGkLGohASAAQQEgBHQiBHEEfyABQQhqIgAhBCAAKAIABUH8KyAAIARyNgIAIAFBCGohBCABCyEAIAQgAjYCACAAQQxqIAI2AgAgAkEIaiAANgIAIAJBDGogATYCAAtBhCwgAzYCAEGQLCAGNgIAIAokAiAIDwtBgCwoAgAiCwR/IAtBACALa3FBf2oiAEEMdkEQcSIBIAAgAXYiAEEFdkEIcSIBciAAIAF2IgBBAnZBBHEiAXIgACABdiIAQQF2QQJxIgFyIAAgAXYiAEEBdkEBcSIBciAAIAF2akECdEGsLmooAgAiAEEEaigCAEF4cSACayEIIAAhBQNAAkAgAEEQaigCACIBBEAgASEABSAAQRRqKAIAIgBFDQELIABBBGooAgBBeHEgAmsiBCAISSEBIAQgCCABGyEIIAAgBSABGyEFDAELCyACIAVqIgwgBUsEfyAFQRhqKAIAIQkgBUEMaigCACIAIAVGBEACQCAFQRRqIgEoAgAiAEUEQCAFQRBqIgEoAgAiAEUEQEEAIQAMAgsLA0ACQCAAQRRqIgQoAgAiBgR/IAQhASAGBSAAQRBqIgQoAgAiBkUNASAEIQEgBgshAAwBCwsgAUEANgIACwUgBUEIaigCACIBQQxqIAA2AgAgAEEIaiABNgIACyAJBEACQCAFQRxqKAIAIgFBAnRBrC5qIgQoAgAgBUYEQCAEIAA2AgAgAEUEQEGALCALQQEgAXRBf3NxNgIADAILBSAJQRBqIgEgCUEUaiABKAIAIAVGGyAANgIAIABFDQELIABBGGogCTYCACAFQRBqKAIAIgEEQCAAQRBqIAE2AgAgAUEYaiAANgIACyAFQRRqKAIAIgEEQCAAQRRqIAE2AgAgAUEYaiAANgIACwsLIAhBEEkEQCAFQQRqIAIgCGoiAEEDcjYCACAAIAVqQQRqIgAgACgCAEEBcjYCAAUgBUEEaiACQQNyNgIAIAxBBGogCEEBcjYCACAIIAxqIAg2AgAgBwRAQZAsKAIAIQIgB0EDdiIBQQN0QaQsaiEAIANBASABdCIBcQR/IABBCGoiASEDIAEoAgAFQfwrIAEgA3I2AgAgAEEIaiEDIAALIQEgAyACNgIAIAFBDGogAjYCACACQQhqIAE2AgAgAkEMaiAANgIAC0GELCAINgIAQZAsIAw2AgALIAokAiAFQQhqDwUgAgsFIAILBSACCwUgAEG/f0sEf0F/BQJ/IABBC2oiAEF4cSEBQYAsKAIAIgQEf0EAIAFrIQICfwJAIABBCHYiAAR/IAFB////B0sEf0EfBSAAIABBgP4/akEQdkEIcSIGdCIDQYDgH2pBEHZBBHEhACADIAB0IgVBgIAPakEQdkECcSEDIAFBDiAAIAZyIANyayAFIAN0QQ92aiIAQQdqdkEBcSAAQQF0cgsFQQALIgdBAnRBrC5qKAIAIgAEQEEAIQUgAUEAQRkgB0EBdmsgB0EfRht0IQZBACEDA0AgAEEEaigCAEF4cSABayIIIAJJBEAgCAR/IAAhAyAIBUEAIQMgACECDAQLIQILIAUgAEEUaigCACIFIAVFIAUgAEEQaiAGQR92QQJ0aigCACIIRnIbIQAgBkEBdCEGIAgEQCAAIQUgCCEADAELCwVBACEAQQAhAwsgACADcgR/IAAhBiADBSABIARBAiAHdCIAQQAgAGtycSIARQ0EGiAAQQAgAGtxQX9qIgBBDHZBEHEiAyAAIAN2IgBBBXZBCHEiA3IgACADdiIAQQJ2QQRxIgNyIAAgA3YiAEEBdkECcSIDciAAIAN2IgBBAXZBAXEiA3IgACADdmpBAnRBrC5qKAIAIQZBAAshACAGBH8gAiEDIAYhAgwBBSACIQYgAAsMAQsDfyACQQRqKAIAQXhxIAFrIgUgA0khBiAFIAMgBhshAyACIAAgBhshACACQRBqKAIAIgYEfyAGBSACQRRqKAIACyICDQAgAyEGIAALCyIDBH8gBkGELCgCACABa0kEfyABIANqIgcgA0sEfyADQRhqKAIAIQkgA0EMaigCACIAIANGBEACQCADQRRqIgIoAgAiAEUEQCADQRBqIgIoAgAiAEUEQEEAIQAMAgsLA0ACQCAAQRRqIgUoAgAiCAR/IAUhAiAIBSAAQRBqIgUoAgAiCEUNASAFIQIgCAshAAwBCwsgAkEANgIACwUgA0EIaigCACICQQxqIAA2AgAgAEEIaiACNgIACyAJBEACQCADQRxqKAIAIgJBAnRBrC5qIgUoAgAgA0YEQCAFIAA2AgAgAEUEQEGALCAEQQEgAnRBf3NxIgA2AgAMAgsFIAlBEGoiAiAJQRRqIAIoAgAgA0YbIAA2AgAgAEUEQCAEIQAMAgsLIABBGGogCTYCACADQRBqKAIAIgIEQCAAQRBqIAI2AgAgAkEYaiAANgIACyADQRRqKAIAIgIEfyAAQRRqIAI2AgAgAkEYaiAANgIAIAQFIAQLIQALBSAEIQALIAZBEEkEQCADQQRqIAEgBmoiAEEDcjYCACAAIANqQQRqIgAgACgCAEEBcjYCAAUCQCADQQRqIAFBA3I2AgAgB0EEaiAGQQFyNgIAIAYgB2ogBjYCACAGQQN2IQEgBkGAAkkEQCABQQN0QaQsaiEAQfwrKAIAIgJBASABdCIBcQR/IABBCGoiASECIAEoAgAFQfwrIAEgAnI2AgAgAEEIaiECIAALIQEgAiAHNgIAIAFBDGogBzYCACAHQQhqIAE2AgAgB0EMaiAANgIADAELIAZBCHYiAQR/IAZB////B0sEf0EfBSABIAFBgP4/akEQdkEIcSIEdCICQYDgH2pBEHZBBHEhASACIAF0IgVBgIAPakEQdkECcSECIAZBDiABIARyIAJyayAFIAJ0QQ92aiIBQQdqdkEBcSABQQF0cgsFQQALIgFBAnRBrC5qIQIgB0EcaiABNgIAIAdBEGoiBEEEakEANgIAIARBADYCACAAQQEgAXQiBHFFBEBBgCwgACAEcjYCACACIAc2AgAgB0EYaiACNgIAIAdBDGogBzYCACAHQQhqIAc2AgAMAQsgAigCACIAQQRqKAIAQXhxIAZGBEAgACEBBQJAIAZBAEEZIAFBAXZrIAFBH0YbdCECA0AgAEEQaiACQR92QQJ0aiIEKAIAIgEEQCACQQF0IQIgAUEEaigCAEF4cSAGRg0CIAEhAAwBCwsgBCAHNgIAIAdBGGogADYCACAHQQxqIAc2AgAgB0EIaiAHNgIADAILCyABQQhqIgAoAgAiAkEMaiAHNgIAIAAgBzYCACAHQQhqIAI2AgAgB0EMaiABNgIAIAdBGGpBADYCAAsLIAokAiADQQhqDwUgAQsFIAELBSABCwUgAQsLCwshAEGELCgCACICIABPBEBBkCwoAgAhASACIABrIgNBD0sEQEGQLCAAIAFqIgQ2AgBBhCwgAzYCACAEQQRqIANBAXI2AgAgASACaiADNgIAIAFBBGogAEEDcjYCAAVBhCxBADYCAEGQLEEANgIAIAFBBGogAkEDcjYCACABIAJqQQRqIgAgACgCAEEBcjYCAAsgCiQCIAFBCGoPC0GILCgCACICIABLBEBBiCwgAiAAayICNgIAQZQsQZQsKAIAIgEgAGoiAzYCACADQQRqIAJBAXI2AgAgAUEEaiAAQQNyNgIAIAokAiABQQhqDwsgAEEwaiEGQdQvKAIABH9B3C8oAgAFQdwvQYAgNgIAQdgvQYAgNgIAQeAvQX82AgBB5C9BfzYCAEHoL0EANgIAQbgvQQA2AgBB1C8gCUFwcUHYqtWqBXM2AgBBgCALIgEgAEEvaiIFaiIIQQAgAWsiCXEiBCAATQRAIAokAkEADwtBtC8oAgAiAQRAQawvKAIAIgMgBGoiByADTSAHIAFLcgRAIAokAkEADwsLAkACQEG4LygCAEEEcQRAQQAhAgUCQAJAAkBBlCwoAgAiAUUNAEG8LyEDA0ACQCADKAIAIgcgAU0EQCAHIANBBGooAgBqIAFLDQELIANBCGooAgAiAw0BDAILCyAIIAJrIAlxIgJB/////wdJBEAgAhBeIQEgASADKAIAIANBBGooAgBqRw0CIAFBf0cNBQVBACECCwwCC0EAEF4iAUF/RgR/QQAFQawvKAIAIgggAUHYLygCACICQX9qIgNqQQAgAmtxIAFrQQAgASADcRsgBGoiAmohAyACQf////8HSSACIABLcQR/QbQvKAIAIgkEQCADIAhNIAMgCUtyBEBBACECDAULCyABIAIQXiIDRg0FIAMhAQwCBUEACwshAgwBC0EAIAJrIQggAUF/RyACQf////8HSXEgBiACS3FFBEAgAUF/RgRAQQAhAgwCBQwECwALQdwvKAIAIgMgBSACa2pBACADa3EiA0H/////B08NAiADEF5Bf0YEfyAIEF4aQQAFIAIgA2ohAgwDCyECC0G4L0G4LygCAEEEcjYCAAsgBEH/////B0kEQCAEEF4hAUEAEF4iAyABayIGIABBKGpLIQQgBiACIAQbIQIgBEEBcyABQX9GciABQX9HIANBf0dxIAEgA0lxQQFzckUNAQsMAQtBrC9BrC8oAgAgAmoiAzYCACADQbAvKAIASwRAQbAvIAM2AgALQZQsKAIAIgQEQAJAQbwvIQMCQAJAA0AgAygCACIGIANBBGooAgAiBWogAUYNASADQQhqKAIAIgMNAAsMAQsgA0EEaiEIIANBDGooAgBBCHFFBEAgBiAETSABIARLcQRAIAggAiAFajYCACAEQQAgBEEIaiIBa0EHcUEAIAFBB3EbIgNqIQFBiCwoAgAgAmoiBiADayECQZQsIAE2AgBBiCwgAjYCACABQQRqIAJBAXI2AgAgBCAGakEEakEoNgIAQZgsQeQvKAIANgIADAMLCwsgAUGMLCgCAEkEQEGMLCABNgIACyABIAJqIQZBvC8hAwJAAkADQCADKAIAIAZGDQEgA0EIaigCACIDDQALDAELIANBDGooAgBBCHFFBEAgAyABNgIAIANBBGoiAyADKAIAIAJqNgIAQQAgAUEIaiICa0EHcUEAIAJBB3EbIAFqIgkgAGohBSAGQQAgBkEIaiIBa0EHcUEAIAFBB3EbaiICIAlrIABrIQMgCUEEaiAAQQNyNgIAIAIgBEYEQEGILEGILCgCACADaiIANgIAQZQsIAU2AgAgBUEEaiAAQQFyNgIABQJAQZAsKAIAIAJGBEBBhCxBhCwoAgAgA2oiADYCAEGQLCAFNgIAIAVBBGogAEEBcjYCACAAIAVqIAA2AgAMAQsgAkEEaigCACIAQQNxQQFGBEAgAEF4cSEHIABBA3YhBCAAQYACSQRAIAJBCGooAgAiACACQQxqKAIAIgFGBEBB/CtB/CsoAgBBASAEdEF/c3E2AgAFIABBDGogATYCACABQQhqIAA2AgALBQJAIAJBGGooAgAhCCACQQxqKAIAIgAgAkYEQAJAIAJBEGoiAUEEaiIEKAIAIgAEQCAEIQEFIAEoAgAiAEUEQEEAIQAMAgsLA0ACQCAAQRRqIgQoAgAiBgR/IAQhASAGBSAAQRBqIgQoAgAiBkUNASAEIQEgBgshAAwBCwsgAUEANgIACwUgAkEIaigCACIBQQxqIAA2AgAgAEEIaiABNgIACyAIRQ0AIAJBHGooAgAiAUECdEGsLmoiBCgCACACRgRAAkAgBCAANgIAIAANAEGALEGALCgCAEEBIAF0QX9zcTYCAAwCCwUgCEEQaiIBIAhBFGogASgCACACRhsgADYCACAARQ0BCyAAQRhqIAg2AgAgAkEQaiIEKAIAIgEEQCAAQRBqIAE2AgAgAUEYaiAANgIACyAEQQRqKAIAIgFFDQAgAEEUaiABNgIAIAFBGGogADYCAAsLIAIgB2ohAiADIAdqIQMLIAJBBGoiACAAKAIAQX5xNgIAIAVBBGogA0EBcjYCACADIAVqIAM2AgAgA0EDdiEBIANBgAJJBEAgAUEDdEGkLGohAEH8KygCACICQQEgAXQiAXEEfyAAQQhqIgEhAiABKAIABUH8KyABIAJyNgIAIABBCGohAiAACyEBIAIgBTYCACABQQxqIAU2AgAgBUEIaiABNgIAIAVBDGogADYCAAwBCyADQQh2IgAEfyADQf///wdLBH9BHwUgACAAQYD+P2pBEHZBCHEiAnQiAUGA4B9qQRB2QQRxIQAgASAAdCIEQYCAD2pBEHZBAnEhASADQQ4gACACciABcmsgBCABdEEPdmoiAEEHanZBAXEgAEEBdHILBUEACyIBQQJ0QawuaiEAIAVBHGogATYCACAFQRBqIgJBBGpBADYCACACQQA2AgBBgCwoAgAiAkEBIAF0IgRxRQRAQYAsIAIgBHI2AgAgACAFNgIAIAVBGGogADYCACAFQQxqIAU2AgAgBUEIaiAFNgIADAELIAAoAgAiAEEEaigCAEF4cSADRgRAIAAhAQUCQCADQQBBGSABQQF2ayABQR9GG3QhAgNAIABBEGogAkEfdkECdGoiBCgCACIBBEAgAkEBdCECIAFBBGooAgBBeHEgA0YNAiABIQAMAQsLIAQgBTYCACAFQRhqIAA2AgAgBUEMaiAFNgIAIAVBCGogBTYCAAwCCwsgAUEIaiIAKAIAIgJBDGogBTYCACAAIAU2AgAgBUEIaiACNgIAIAVBDGogATYCACAFQRhqQQA2AgALCyAKJAIgCUEIag8LC0G8LyEDA0ACQCADKAIAIgYgBE0EQCAGIANBBGooAgBqIgUgBEsNAQsgA0EIaigCACEDDAELCyAFQVFqIgZBCGohAyAEIAZBACADa0EHcUEAIANBB3EbaiIDIAMgBEEQaiIJSRsiA0EIaiEGQZQsQQAgAUEIaiIIa0EHcUEAIAhBB3EbIgggAWoiBzYCAEGILCACQVhqIgsgCGsiCDYCACAHQQRqIAhBAXI2AgAgASALakEEakEoNgIAQZgsQeQvKAIANgIAIANBBGoiCEEbNgIAIAZBvC8pAgA3AgAgBkHELykCADcCCEG8LyABNgIAQcAvIAI2AgBByC9BADYCAEHELyAGNgIAIANBGGohAQNAIAFBBGoiAkEHNgIAIAFBCGogBUkEQCACIQEMAQsLIAMgBEcEQCAIIAgoAgBBfnE2AgAgBEEEaiADIARrIgZBAXI2AgAgAyAGNgIAIAZBA3YhAiAGQYACSQRAIAJBA3RBpCxqIQFB/CsoAgAiA0EBIAJ0IgJxBH8gAUEIaiICIQMgAigCAAVB/CsgAiADcjYCACABQQhqIQMgAQshAiADIAQ2AgAgAkEMaiAENgIAIARBCGogAjYCACAEQQxqIAE2AgAMAgsgBkEIdiIBBH8gBkH///8HSwR/QR8FIAEgAUGA/j9qQRB2QQhxIgN0IgJBgOAfakEQdkEEcSEBIAIgAXQiBUGAgA9qQRB2QQJxIQIgBkEOIAEgA3IgAnJrIAUgAnRBD3ZqIgFBB2p2QQFxIAFBAXRyCwVBAAsiAkECdEGsLmohASAEQRxqIAI2AgAgBEEUakEANgIAIAlBADYCAEGALCgCACIDQQEgAnQiBXFFBEBBgCwgAyAFcjYCACABIAQ2AgAgBEEYaiABNgIAIARBDGogBDYCACAEQQhqIAQ2AgAMAgsgASgCACIBQQRqKAIAQXhxIAZGBEAgASECBQJAIAZBAEEZIAJBAXZrIAJBH0YbdCEDA0AgAUEQaiADQR92QQJ0aiIFKAIAIgIEQCADQQF0IQMgAkEEaigCAEF4cSAGRg0CIAIhAQwBCwsgBSAENgIAIARBGGogATYCACAEQQxqIAQ2AgAgBEEIaiAENgIADAMLCyACQQhqIgEoAgAiA0EMaiAENgIAIAEgBDYCACAEQQhqIAM2AgAgBEEMaiACNgIAIARBGGpBADYCAAsLBUGMLCgCACIDRSABIANJcgRAQYwsIAE2AgALQbwvIAE2AgBBwC8gAjYCAEHIL0EANgIAQaAsQdQvKAIANgIAQZwsQX82AgBBsCxBpCw2AgBBrCxBpCw2AgBBuCxBrCw2AgBBtCxBrCw2AgBBwCxBtCw2AgBBvCxBtCw2AgBByCxBvCw2AgBBxCxBvCw2AgBB0CxBxCw2AgBBzCxBxCw2AgBB2CxBzCw2AgBB1CxBzCw2AgBB4CxB1Cw2AgBB3CxB1Cw2AgBB6CxB3Cw2AgBB5CxB3Cw2AgBB8CxB5Cw2AgBB7CxB5Cw2AgBB+CxB7Cw2AgBB9CxB7Cw2AgBBgC1B9Cw2AgBB/CxB9Cw2AgBBiC1B/Cw2AgBBhC1B/Cw2AgBBkC1BhC02AgBBjC1BhC02AgBBmC1BjC02AgBBlC1BjC02AgBBoC1BlC02AgBBnC1BlC02AgBBqC1BnC02AgBBpC1BnC02AgBBsC1BpC02AgBBrC1BpC02AgBBuC1BrC02AgBBtC1BrC02AgBBwC1BtC02AgBBvC1BtC02AgBByC1BvC02AgBBxC1BvC02AgBB0C1BxC02AgBBzC1BxC02AgBB2C1BzC02AgBB1C1BzC02AgBB4C1B1C02AgBB3C1B1C02AgBB6C1B3C02AgBB5C1B3C02AgBB8C1B5C02AgBB7C1B5C02AgBB+C1B7C02AgBB9C1B7C02AgBBgC5B9C02AgBB/C1B9C02AgBBiC5B/C02AgBBhC5B/C02AgBBkC5BhC42AgBBjC5BhC42AgBBmC5BjC42AgBBlC5BjC42AgBBoC5BlC42AgBBnC5BlC42AgBBqC5BnC42AgBBpC5BnC42AgBBlCxBACABQQhqIgNrQQdxQQAgA0EHcRsiAyABaiIENgIAQYgsIAJBWGoiAiADayIDNgIAIARBBGogA0EBcjYCACABIAJqQQRqQSg2AgBBmCxB5C8oAgA2AgALQYgsKAIAIgEgAEsEQEGILCABIABrIgI2AgBBlCxBlCwoAgAiASAAaiIDNgIAIANBBGogAkEBcjYCACABQQRqIABBA3I2AgAgCiQCIAFBCGoPCwsQTUEMNgIAIAokAkEAC8gPAQh/IABFBEAPC0GMLCgCACEEIABBeGoiASAAQXxqKAIAIgNBeHEiAGohBiADQQFxBEAgASECBQJ/IAEoAgAhAiADQQNxRQRADwsgACACaiEDIAEgAmsiACAESQRADwtBkCwoAgAgAEYEQCAGQQRqIgEoAgAiAkEDcUEDRwRAIAAhASAAIQIgAwwCC0GELCADNgIAIAEgAkF+cTYCACAAQQRqIANBAXI2AgAgACADaiADNgIADwsgAkEDdiEEIAJBgAJJBEAgAEEIaigCACIBIABBDGooAgAiAkYEQEH8K0H8KygCAEEBIAR0QX9zcTYCACAAIQEgACECIAMMAgUgAUEMaiACNgIAIAJBCGogATYCACAAIQEgACECIAMMAgsACyAAQRhqKAIAIQcgAEEMaigCACIBIABGBEACQCAAQRBqIgJBBGoiBCgCACIBBEAgBCECBSACKAIAIgFFBEBBACEBDAILCwNAAkAgAUEUaiIEKAIAIgUEfyAEIQIgBQUgAUEQaiIEKAIAIgVFDQEgBCECIAULIQEMAQsLIAJBADYCAAsFIABBCGooAgAiAkEMaiABNgIAIAFBCGogAjYCAAsgBwR/IABBHGooAgAiAkECdEGsLmoiBCgCACAARgRAIAQgATYCACABRQRAQYAsQYAsKAIAQQEgAnRBf3NxNgIAIAAhASAAIQIgAwwDCwUgB0EQaiICIAdBFGogAigCACAARhsgATYCACABRQRAIAAhASAAIQIgAwwDCwsgAUEYaiAHNgIAIABBEGoiBCgCACICBEAgAUEQaiACNgIAIAJBGGogATYCAAsgBEEEaigCACICBH8gAUEUaiACNgIAIAJBGGogATYCACAAIQEgACECIAMFIAAhASAAIQIgAwsFIAAhASAAIQIgAwsLIQALIAEgBk8EQA8LIAZBBGoiBCgCACIDQQFxRQRADwsgA0ECcQR/IAQgA0F+cTYCACACQQRqIABBAXI2AgAgACABaiAANgIAIAAFQZQsKAIAIAZGBEBBiCxBiCwoAgAgAGoiADYCAEGULCACNgIAIAJBBGogAEEBcjYCACACQZAsKAIARwRADwtBkCxBADYCAEGELEEANgIADwtBkCwoAgAgBkYEQEGELEGELCgCACAAaiIANgIAQZAsIAE2AgAgAkEEaiAAQQFyNgIAIAAgAWogADYCAA8LIANBeHEgAGohBCADQQN2IQUgA0GAAkkEQCAGQQhqKAIAIgAgBkEMaigCACIDRgRAQfwrQfwrKAIAQQEgBXRBf3NxNgIABSAAQQxqIAM2AgAgA0EIaiAANgIACwUCQCAGQRhqKAIAIQggBkEMaigCACIAIAZGBEACQCAGQRBqIgNBBGoiBSgCACIABEAgBSEDBSADKAIAIgBFBEBBACEADAILCwNAAkAgAEEUaiIFKAIAIgcEfyAFIQMgBwUgAEEQaiIFKAIAIgdFDQEgBSEDIAcLIQAMAQsLIANBADYCAAsFIAZBCGooAgAiA0EMaiAANgIAIABBCGogAzYCAAsgCARAIAZBHGooAgAiA0ECdEGsLmoiBSgCACAGRgRAIAUgADYCACAARQRAQYAsQYAsKAIAQQEgA3RBf3NxNgIADAMLBSAIQRBqIgMgCEEUaiADKAIAIAZGGyAANgIAIABFDQILIABBGGogCDYCACAGQRBqIgUoAgAiAwRAIABBEGogAzYCACADQRhqIAA2AgALIAVBBGooAgAiAwRAIABBFGogAzYCACADQRhqIAA2AgALCwsLIAJBBGogBEEBcjYCACABIARqIAQ2AgBBkCwoAgAgAkYEf0GELCAENgIADwUgBAsLIgNBA3YhASADQYACSQRAIAFBA3RBpCxqIQBB/CsoAgAiA0EBIAF0IgFxBH8gAEEIaiIBIQMgASgCAAVB/CsgASADcjYCACAAQQhqIQMgAAshASADIAI2AgAgAUEMaiACNgIAIAJBCGogATYCACACQQxqIAA2AgAPCyADQQh2IgAEfyADQf///wdLBH9BHwUgACAAQYD+P2pBEHZBCHEiBHQiAUGA4B9qQRB2QQRxIQAgASAAdCIFQYCAD2pBEHZBAnEhASADQQ4gACAEciABcmsgBSABdEEPdmoiAEEHanZBAXEgAEEBdHILBUEACyIBQQJ0QawuaiEAIAJBHGogATYCACACQRRqQQA2AgAgAkEQakEANgIAQYAsKAIAIgRBASABdCIFcQRAAkAgACgCACIAQQRqKAIAQXhxIANGBEAgACEBBQJAIANBAEEZIAFBAXZrIAFBH0YbdCEEA0AgAEEQaiAEQR92QQJ0aiIFKAIAIgEEQCAEQQF0IQQgAUEEaigCAEF4cSADRg0CIAEhAAwBCwsgBSACNgIAIAJBGGogADYCACACQQxqIAI2AgAgAkEIaiACNgIADAILCyABQQhqIgAoAgAiA0EMaiACNgIAIAAgAjYCACACQQhqIAM2AgAgAkEMaiABNgIAIAJBGGpBADYCAAsFQYAsIAQgBXI2AgAgACACNgIAIAJBGGogADYCACACQQxqIAI2AgAgAkEIaiACNgIAC0GcLEGcLCgCAEF/aiIANgIAIAAEQA8LQcQvIQADQCAAKAIAIgFBCGohACABDQALQZwsQX82AgALLAAgACgCAEHft96aAUYEQEEADwsgAUEBcUEaahEBACAAQd+33poBNgIAQQALxgMBA38gAkGAwABOBEAgACABIAIQCBogAA8LIAAhBCAAIAJqIQMgAEEDcSABQQNxRgRAA0AgAEEDcQRAIAJFBEAgBA8LIAAgASwAADoAACAAQQFqIQAgAUEBaiEBIAJBAWshAgwBCwsgA0F8cSICQUBqIQUDQCAAIAVMBEAgACABKAIANgIAIAAgASgCBDYCBCAAIAEoAgg2AgggACABKAIMNgIMIAAgASgCEDYCECAAIAEoAhQ2AhQgACABKAIYNgIYIAAgASgCHDYCHCAAIAEoAiA2AiAgACABKAIkNgIkIAAgASgCKDYCKCAAIAEoAiw2AiwgACABKAIwNgIwIAAgASgCNDYCNCAAIAEoAjg2AjggACABKAI8NgI8IABBQGshACABQUBrIQEMAQsLA0AgACACSARAIAAgASgCADYCACAAQQRqIQAgAUEEaiEBDAELCwUgA0EEayECA0AgACACSARAIAAgASwAADoAACAAIAEsAAE6AAEgACABLAACOgACIAAgASwAAzoAAyAAQQRqIQAgAUEEaiEBDAELCwsDQCAAIANIBEAgACABLAAAOgAAIABBAWohACABQQFqIQEMAQsLIAQLmAIBBH8gACACaiEEIAFB/wFxIQEgAkHDAE4EQANAIABBA3EEQCAAIAE6AAAgAEEBaiEADAELCyABQQh0IAFyIAFBEHRyIAFBGHRyIQMgBEF8cSIFQUBqIQYDQCAAIAZMBEAgACADNgIAIAAgAzYCBCAAIAM2AgggACADNgIM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9eO65H7lQ+YI583nk+hZ6R/q5eqr63LsOe0A7sfuju9V8B3x5fGt8nXzPfQF9c71lvZf9yf48Pi5+YL6SvsT/Nz8pf1u/jf/AQCAAAIAQAADAMAABAAgAAUAoAAGAGAABwDgAAgAEAAJAJAACgBQAAsA0AAMADAADQCwAA4AcAAPAPAAEQCIABIASAATAMgAFAAoABUAqAAWAGgAFwDoABkAmAAaAFgAGwDYABwAOAAdALgAHgB4AB8A+AAhAIQAIgBEACMAxAAlAKQAJgBkACcA5AApAJQAKgBUACsA1AAsADQALQC0AC4AdAAvAPQAMQCMADIATAAzAMwANQCsADYAbAA3AOwAOQCcADoAXAA7ANwAPQC8AD4AfAA/APwAQQCCAEMAwgBFAKIARgBiAEcA4gBJAJIASgBSAEsA0gBNALIATgByAE8A8gBRAIoAUwDKAFUAqgBWAGoAVwDqAFkAmgBbANoAXQC6AF4AegBfAPoAYQCGAGMAxgBlAKYAZwDmAGkAlgBrANYAbQC2AG4AdgBvAPYAcQCOAHMAzgB1AK4AdwDuAHkAngB7AN4AfQC+AH8A/gCDAMEAhQChAIcA4QCJAJEAiwDRAI0AsQCPAPEAkwDJAJUAqQCXAOkAmwDZAJ0AuQCfAPkAowDFAKcA5QCrANUArQC1AK8A9QCzAM0AtwDtALsA3QC/AP0AxwDjAMsA0wDPAPMA1wDrAN8A+wDvAPcAAQBAAAIAIAADAGAABAAQAAUAUAAGADAABwBwAAkASAAKACgACwBoAAwAGAANAFgADgA4AA8AeAARAEQAEgAkABMAZAAVAFQAFgA0ABcAdAAZAEwAGgAsABsAbAAdAFwAHgA8AB8AfAAhAEIAIwBiACUAUgAmADIAJwByACkASgArAGoALQBaAC4AOgAvAHoAMQBGADMAZgA1AFYANwB2ADkATgA7AG4APQBeAD8AfgBDAGEARQBRAEcAcQBLAGkATQBZAE8AeQBTAGUAVwB1AFsAbQBfAH0AZwBzAG8AewAFAEGMHwsBAQBBpB8LDgEAAAABAAAA6BEAAAAEAEG8HwsBAQBByx8LBQr/////AEGQIAvMA4APAAAYABUAGAA5ADAAOQAIAAQAAwAOAAcABQAlACAAJQBkAFAAZABSAE4AUgAdAQQBHQEGAAMAAgAJAAUAAwBeAF4AXgBMBBoETAQGAAgACgAMAA4AEACAAgADIAIgAkACQAJAAkACgCyALAAtAC0ALQAtACSAIwAjgCIAIoAhZGF0YVswXSA9PSB2YWwwAG1haW4uYwBwcm9jZXNzX2RhdGEAZGF0YVsxMDBdID09IHZhbDEwMABkYXRhWzIwMDBdID09IHZhbDIwMDAAcHJvY2Vzc19kYXRhOiBkYXRhID09IE5VTEwgAGRhdGFfbGVuZ3RoID49IDAAd2VicnRjL2NvbW1vbl9hdWRpby92YWQvdmFkX2ZpbHRlcmJhbmsuYwBXZWJSdGNWYWRfQ2FsY3VsYXRlRmVhdHVyZXMAZGF0YV9sZW5ndGggPD0gMjQwAGRhdGFfaW4gIT0gTlVMTABMb2dPZkVuZXJneQBkYXRhX2xlbmd0aCA+IDAAY2hhbm5lbCA8IGtOdW1DaGFubmVscwB3ZWJydGMvY29tbW9uX2F1ZGlvL3ZhZC92YWRfc3AuYwBXZWJSdGNWYWRfRmluZE1pbmltdW0=";
var WebRtcVad = (function() {

    return (function(WebRtcVad) {
        WebRtcVad = WebRtcVad || {};
		
		// Copyright 2010 The Emscripten Authors.  All rights reserved.
		// Emscripten is available under two separate licenses, the MIT license and the
		// University of Illinois/NCSA Open Source License.  Both these licenses can be
		// found in the LICENSE file.

		// The Module object: Our interface to the outside world. We import
		// and export values on it. There are various ways Module can be used:
		// 1. Not defined. We create it here
		// 2. A function parameter, function(Module) { ..generated code.. }
		// 3. pre-run appended it, var Module = {}; ..generated code..
		// 4. External script tag defines var Module.
		// We need to check if Module already exists (e.g. case 3 above).
		// Substitution will be replaced with actual code on later stage of the build,
		// this way Closure Compiler will not mangle it (e.g. case 4. above).
		// Note that if you want to run closure, and also to use Module
		// after the generated code, you will need to define   var Module = {};
		// before the code. Then that object will be used in the code, and you
		// can continue to use Module afterwards as well.
		var Module = typeof WebRtcVad !== 'undefined' ? WebRtcVad : {};
		var wasmBinaryFile = webRtcVadWasmBinaryFile;
		
		var readyPromiseResolve, readyPromiseReject;		//TODO: use 'readyPromiseReject' somewhere?
        Module["ready"] = new Promise(function(resolve, reject) {
            readyPromiseResolve = resolve;
            readyPromiseReject = reject
        });

		// --pre-jses are emitted after the Module integration code, so that they can
		// refer to Module (if they choose; they can also define Module)
		// {{PRE_JSES}}

		// Sometimes an existing Module object exists with properties
		// meant to overwrite the default module functionality. Here
		// we collect those properties and reapply _after_ we configure
		// the current environment's defaults to avoid having to be so
		// defensive during initialization.
		var moduleOverrides = {};
		var key;
		for (key in Module) {
			if (Module.hasOwnProperty(key)) {
				moduleOverrides[key] = Module[key];
			}
		}

		Module['arguments'] = [];
		Module['thisProgram'] = './this.program';
		Module['quit'] = function(status, toThrow) {
			throw toThrow;
		};
		Module['preRun'] = [];
		Module['postRun'] = [];

		// Determine the runtime environment we are in. You can customize this by
		// setting the ENVIRONMENT setting at compile time (see settings.js).

		var ENVIRONMENT_IS_WEB = false;
		var ENVIRONMENT_IS_WORKER = false;
		var ENVIRONMENT_IS_NODE = false;
		var ENVIRONMENT_HAS_NODE = false;
		var ENVIRONMENT_IS_SHELL = false;
		ENVIRONMENT_IS_WEB = typeof window === 'object';
		ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
		// A web environment like Electron.js can have Node enabled, so we must
		// distinguish between Node-enabled environments and Node environments per se.
		// This will allow the former to do things like mount NODEFS.
		ENVIRONMENT_HAS_NODE = typeof process === 'object' && typeof require === 'function';
		ENVIRONMENT_IS_NODE = ENVIRONMENT_HAS_NODE && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;

		// Three configurations we can be running in:
		// 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)
		// 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)
		// 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)

		if (ENVIRONMENT_IS_NODE) {
			// Expose functionality in the same simple way that the shells work
			// Note that we pollute the global namespace here, otherwise we break in node
			var nodeFS;
			var nodePath;

			if (process['argv'].length > 1) {
				Module['thisProgram'] = process['argv'][1].replace(/\\/g, '/');
			}

			Module['arguments'] = process['argv'].slice(2);

			if (typeof module !== 'undefined') {
				module['exports'] = Module;
			}

			process['on']('uncaughtException', function(ex) {
				// suppress ExitStatus exceptions from showing an error
				if (!(ex instanceof ExitStatus)) {
					throw ex;
				}
			});
			// Currently node will swallow unhandled rejections, but this behavior is
			// deprecated, and in the future it will exit with error status.
			process['on']('unhandledRejection', abort);

			Module['quit'] = function(status) {
				process['exit'](status);
			};

			Module['inspect'] = function() {
				return '[Emscripten Module object]';
			};
		} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
			
			Module['setWindowTitle'] = function(title) {
				document.title = title
			};
		} else {}

		// Set up the out() and err() hooks, which are how we can print to stdout or
		// stderr, respectively.
		// If the user provided Module.print or printErr, use that. Otherwise,
		// console.log is checked first, as 'print' on the web will open a print dialogue
		// printErr is preferable to console.warn (works better in shells)
		// bind(console) is necessary to fix IE/Edge closed dev tools panel behavior.
		var out = Module['print'] || (typeof console !== 'undefined' ? console.log.bind(console) : (typeof print !== 'undefined' ? print : null));
		var err = Module['printErr'] || (typeof printErr !== 'undefined' ? printErr : ((typeof console !== 'undefined' && console.warn.bind(console)) || out));

		// Merge back in the overrides
		for (key in moduleOverrides) {
			if (moduleOverrides.hasOwnProperty(key)) {
				Module[key] = moduleOverrides[key];
			}
		}
		// Free the object hierarchy contained in the overrides, this lets the GC
		// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
		moduleOverrides = undefined;

		// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message

		// Copyright 2017 The Emscripten Authors.  All rights reserved.
		// Emscripten is available under two separate licenses, the MIT license and the
		// University of Illinois/NCSA Open Source License.  Both these licenses can be
		// found in the LICENSE file.

		// {{PREAMBLE_ADDITIONS}}

		var STACK_ALIGN = 16;


		function dynamicAlloc(size) {
			var ret = HEAP32[DYNAMICTOP_PTR >> 2];
			var end = (ret + size + 15) & -16;
			if (end > _emscripten_get_heap_size()) {
				abort();
			}
			HEAP32[DYNAMICTOP_PTR >> 2] = end;
			return ret;
		}

		function alignMemory(size, factor) {
			if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default
			return Math.ceil(size / factor) * factor;
		}

		function getNativeTypeSize(type) {
			switch (type) {
				case 'i1':
				case 'i8':
					return 1;
				case 'i16':
					return 2;
				case 'i32':
					return 4;
				case 'i64':
					return 8;
				case 'float':
					return 4;
				case 'double':
					return 8;
				default: {
					if (type[type.length - 1] === '*') {
						return 4; // A pointer
					} else if (type[0] === 'i') {
						var bits = parseInt(type.substr(1));
						assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
						return bits / 8;
					} else {
						return 0;
					}
				}
			}
		}

		function warnOnce(text) {
			if (!warnOnce.shown) warnOnce.shown = {};
			if (!warnOnce.shown[text]) {
				warnOnce.shown[text] = 1;
				err(text);
			}
		}

		var asm2wasmImports = { // special asm2wasm imports
			"f64-rem": function(x, y) {
				return x % y;
			},
			"debugger": function() {
				debugger;
			}
		};

		var jsCallStartIndex = 1;
		var functionPointers = new Array(0);

		// Wraps a JS function as a wasm function with a given signature.
		// In the future, we may get a WebAssembly.Function constructor. Until then,
		// we create a wasm module that takes the JS function as an import with a given
		// signature, and re-exports that as a wasm function.
		function convertJsFunctionToWasm(func, sig) {

			// The module is static, with the exception of the type section, which is
			// generated based on the signature passed in.
			var typeSection = [
				0x01, // id: section,
				0x00, // length: 0 (placeholder)
				0x01, // count: 1
				0x60, // form: func
			];
			var sigRet = sig.slice(0, 1);
			var sigParam = sig.slice(1);
			var typeCodes = {
				'i': 0x7f, // i32
				'j': 0x7e, // i64
				'f': 0x7d, // f32
				'd': 0x7c, // f64
			};

			// Parameters, length + signatures
			typeSection.push(sigParam.length);
			for (var i = 0; i < sigParam.length; ++i) {
				typeSection.push(typeCodes[sigParam[i]]);
			}

			// Return values, length + signatures
			// With no multi-return in MVP, either 0 (void) or 1 (anything else)
			if (sigRet == 'v') {
				typeSection.push(0x00);
			} else {
				typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);
			}

			// Write the overall length of the type section back into the section header
			// (excepting the 2 bytes for the section id and length)
			typeSection[1] = typeSection.length - 2;

			// Rest of the module is static
			var bytes = new Uint8Array([
				0x00, 0x61, 0x73, 0x6d, // magic ("\0asm")
				0x01, 0x00, 0x00, 0x00, // version: 1
			].concat(typeSection, [
				0x02, 0x07, // import section
				// (import "e" "f" (func 0 (type 0)))
				0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,
				0x07, 0x05, // export section
				// (export "f" (func 0 (type 0)))
				0x01, 0x01, 0x66, 0x00, 0x00,
			]));

			// We can compile this wasm module synchronously because it is very small.
			// This accepts an import (at "e.f"), that it reroutes to an export (at "f")
			var module = new WebAssembly.Module(bytes);
			var instance = new WebAssembly.Instance(module, {
				e: {
					f: func
				}
			});
			var wrappedFunc = instance.exports.f;
			return wrappedFunc;
		}

		// Add a wasm function to the table.
		function addFunctionWasm(func, sig) {
			var table = wasmTable;
			var ret = table.length;

			// Grow the table
			try {
				table.grow(1);
			} catch (err) {
				if (!err instanceof RangeError) {
					throw err;
				}
				throw 'Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH.';
			}

			// Insert new element
			try {
				// Attempting to call this with JS function will cause of table.set() to fail
				table.set(ret, func);
			} catch (err) {
				if (!err instanceof TypeError) {
					throw err;
				}
				assert(typeof sig !== 'undefined', 'Missing signature argument to addFunction');
				var wrapped = convertJsFunctionToWasm(func, sig);
				table.set(ret, wrapped);
			}

			return ret;
		}

		function removeFunctionWasm(index) {
			// TODO(sbc): Look into implementing this to allow re-using of table slots
		}

		// 'sig' parameter is required for the llvm backend but only when func is not
		// already a WebAssembly function.
		function addFunction(func, sig) {
			var base = 0;
			for (var i = base; i < base + 0; i++) {
				if (!functionPointers[i]) {
					functionPointers[i] = func;
					return jsCallStartIndex + i;
				}
			}
			throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';
		}

		function removeFunction(index) {
			functionPointers[index - jsCallStartIndex] = null;
		}

		var funcWrappers = {};

		function getFuncWrapper(func, sig) {
			if (!func) return; // on null pointer, return undefined
			assert(sig);
			if (!funcWrappers[sig]) {
				funcWrappers[sig] = {};
			}
			var sigCache = funcWrappers[sig];
			if (!sigCache[func]) {
				// optimize away arguments usage in common cases
				if (sig.length === 1) {
					sigCache[func] = function dynCall_wrapper() {
						return dynCall(sig, func);
					};
				} else if (sig.length === 2) {
					sigCache[func] = function dynCall_wrapper(arg) {
						return dynCall(sig, func, [arg]);
					};
				} else {
					// general case
					sigCache[func] = function dynCall_wrapper() {
						return dynCall(sig, func, Array.prototype.slice.call(arguments));
					};
				}
			}
			return sigCache[func];
		}


		function makeBigInt(low, high, unsigned) {
			return unsigned ? ((+((low >>> 0))) + ((+((high >>> 0))) * 4294967296.0)) : ((+((low >>> 0))) + ((+((high | 0))) * 4294967296.0));
		}

		function dynCall(sig, ptr, args) {
			if (args && args.length) {
				return Module['dynCall_' + sig].apply(null, [ptr].concat(args));
			} else {
				return Module['dynCall_' + sig].call(null, ptr);
			}
		}

		var tempRet0 = 0;

		var setTempRet0 = function(value) {
			tempRet0 = value;
		}

		var getTempRet0 = function() {
			return tempRet0;
		}

		var Runtime = {};

		// The address globals begin at. Very low in memory, for code size and optimization opportunities.
		// Above 0 is static memory, starting with globals.
		// Then the stack.
		// Then 'dynamic' memory for sbrk.
		var GLOBAL_BASE = 1024;


		// === Preamble library stuff ===

		// Documentation for the public APIs defined in this file must be updated in:
		//    site/source/docs/api_reference/preamble.js.rst
		// A prebuilt local version of the documentation is available at:
		//    site/build/text/docs/api_reference/preamble.js.txt
		// You can also build docs locally as HTML or other formats in site/
		// An online HTML version (which may be of a different version of Emscripten)
		//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

		if (typeof WebAssembly !== 'object') {
			err('no native wasm support detected');
		}

		// In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.
		// In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)

		/** @type {function(number, number, string, boolean=)} */
		function setValue(ptr, value, type, noSafe) {
			type = type || 'i8';
			if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit
			switch (type) {
				case 'i1':
					HEAP8[((ptr) >> 0)] = value;
					break;
				case 'i8':
					HEAP8[((ptr) >> 0)] = value;
					break;
				case 'i16':
					HEAP16[((ptr) >> 1)] = value;
					break;
				case 'i32':
					HEAP32[((ptr) >> 2)] = value;
					break;
				case 'i64':
					(tempI64 = [value >>> 0, (tempDouble = value, (+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble) / 4294967296.0))), 4294967295.0)) | 0) >>> 0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296.0))))) >>> 0) : 0)], HEAP32[((ptr) >> 2)] = tempI64[0], HEAP32[(((ptr) + (4)) >> 2)] = tempI64[1]);
					break;
				case 'float':
					HEAPF32[((ptr) >> 2)] = value;
					break;
				case 'double':
					HEAPF64[((ptr) >> 3)] = value;
					break;
				default:
					abort('invalid type for setValue: ' + type);
			}
		}

		/** @type {function(number, string, boolean=)} */
		function getValue(ptr, type, noSafe) {
			type = type || 'i8';
			if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit
			switch (type) {
				case 'i1':
					return HEAP8[((ptr) >> 0)];
				case 'i8':
					return HEAP8[((ptr) >> 0)];
				case 'i16':
					return HEAP16[((ptr) >> 1)];
				case 'i32':
					return HEAP32[((ptr) >> 2)];
				case 'i64':
					return HEAP32[((ptr) >> 2)];
				case 'float':
					return HEAPF32[((ptr) >> 2)];
				case 'double':
					return HEAPF64[((ptr) >> 3)];
				default:
					abort('invalid type for getValue: ' + type);
			}
			return null;
		}

		// Wasm globals

		var wasmMemory;

		// Potentially used for direct table calls.
		var wasmTable;

		//========================================
		// Runtime essentials
		//========================================

		// whether we are quitting the application. no code should run after this.
		// set in exit() and abort()
		var ABORT = false;

		// set by exit() and abort().  Passed to 'onExit' handler.
		// NOTE: This is also used as the process return code code in shell environments
		// but only when noExitRuntime is false.
		var EXITSTATUS = 0;

		/** @type {function(*, string=)} */
		function assert(condition, text) {
			if (!condition) {
				abort('Assertion failed: ' + text);
			}
		}

		// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
		function getCFunc(ident) {
			var func = Module['_' + ident]; // closure exported function
			assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');
			return func;
		}

		// C calling interface.
		function ccall(ident, returnType, argTypes, args, opts) {
			// For fast lookup of conversion functions
			var toC = {
				'string': function(str) {
					var ret = 0;
					if (str !== null && str !== undefined && str !== 0) { // null string
						// at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
						var len = (str.length << 2) + 1;
						ret = stackAlloc(len);
						stringToUTF8(str, ret, len);
					}
					return ret;
				},
				'array': function(arr) {
					var ret = stackAlloc(arr.length);
					writeArrayToMemory(arr, ret);
					return ret;
				}
			};

			function convertReturnValue(ret) {
				if (returnType === 'string') return UTF8ToString(ret);
				if (returnType === 'boolean') return Boolean(ret);
				return ret;
			}

			var func = getCFunc(ident);
			var cArgs = [];
			var stack = 0;
			if (args) {
				for (var i = 0; i < args.length; i++) {
					var converter = toC[argTypes[i]];
					if (converter) {
						if (stack === 0) stack = stackSave();
						cArgs[i] = converter(args[i]);
					} else {
						cArgs[i] = args[i];
					}
				}
			}
			var ret = func.apply(null, cArgs);
			ret = convertReturnValue(ret);
			if (stack !== 0) stackRestore(stack);
			return ret;
		}

		function cwrap(ident, returnType, argTypes, opts) {
			argTypes = argTypes || [];
			// When the function takes numbers and returns a number, we can just return
			// the original function
			var numericArgs = argTypes.every(function(type) {
				return type === 'number'
			});
			var numericRet = returnType !== 'string';
			if (numericRet && numericArgs && !opts) {
				return getCFunc(ident);
			}
			return function() {
				return ccall(ident, returnType, argTypes, arguments, opts);
			}
		}

		var ALLOC_NORMAL = 0; // Tries to use _malloc()
		var ALLOC_STACK = 1; // Lives for the duration of the current function call
		var ALLOC_DYNAMIC = 2; // Cannot be freed except through sbrk
		var ALLOC_NONE = 3; // Do not allocate

		// allocate(): This is for internal use. You can use it yourself as well, but the interface
		//             is a little tricky (see docs right below). The reason is that it is optimized
		//             for multiple syntaxes to save space in generated code. So you should
		//             normally not use allocate(), and instead allocate memory using _malloc(),
		//             initialize it with setValue(), and so forth.
		// @slab: An array of data, or a number. If a number, then the size of the block to allocate,
		//        in *bytes* (note that this is sometimes confusing: the next parameter does not
		//        affect this!)
		// @types: Either an array of types, one for each byte (or 0 if no type at that position),
		//         or a single type which is used for the entire block. This only matters if there
		//         is initial data - if @slab is a number, then this does not matter at all and is
		//         ignored.
		// @allocator: How to allocate memory, see ALLOC_*
		/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */
		function allocate(slab, types, allocator, ptr) {
			var zeroinit, size;
			if (typeof slab === 'number') {
				zeroinit = true;
				size = slab;
			} else {
				zeroinit = false;
				size = slab.length;
			}

			var singleType = typeof types === 'string' ? types : null;

			var ret;
			if (allocator == ALLOC_NONE) {
				ret = ptr;
			} else {
				ret = [_malloc,
					stackAlloc,
					dynamicAlloc
				][allocator](Math.max(size, singleType ? 1 : types.length));
			}

			if (zeroinit) {
				var stop;
				ptr = ret;
				assert((ret & 3) == 0);
				stop = ret + (size & ~3);
				for (; ptr < stop; ptr += 4) {
					HEAP32[((ptr) >> 2)] = 0;
				}
				stop = ret + size;
				while (ptr < stop) {
					HEAP8[((ptr++) >> 0)] = 0;
				}
				return ret;
			}

			if (singleType === 'i8') {
				if (slab.subarray || slab.slice) {
					HEAPU8.set( /** @type {!Uint8Array} */ (slab), ret);
				} else {
					HEAPU8.set(new Uint8Array(slab), ret);
				}
				return ret;
			}

			var i = 0,
				type, typeSize, previousType;
			while (i < size) {
				var curr = slab[i];

				type = singleType || types[i];
				if (type === 0) {
					i++;
					continue;
				}

				if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

				setValue(ret + i, curr, type);

				// no need to look up size unless type changes, so cache it
				if (previousType !== type) {
					typeSize = getNativeTypeSize(type);
					previousType = type;
				}
				i += typeSize;
			}

			return ret;
		}

		// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready
		function getMemory(size) {
			if (!runtimeInitialized) return dynamicAlloc(size);
			return _malloc(size);
		}

		/** @type {function(number, number=)} */
		function Pointer_stringify(ptr, length) {
			abort("this function has been removed - you should use UTF8ToString(ptr, maxBytesToRead) instead!");
		}

		// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
		// a copy of that string as a Javascript String object.

		function AsciiToString(ptr) {
			var str = '';
			while (1) {
				var ch = HEAPU8[((ptr++) >> 0)];
				if (!ch) return str;
				str += String.fromCharCode(ch);
			}
		}

		// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
		// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

		function stringToAscii(str, outPtr) {
			return writeAsciiToMemory(str, outPtr, false);
		}


		// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
		// a copy of that string as a Javascript String object.

		var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;

		/**
		 * @param {number} idx
		 * @param {number=} maxBytesToRead
		 * @return {string}
		 */
		function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {
			var endIdx = idx + maxBytesToRead;
			var endPtr = idx;
			// TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
			// Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
			// (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)
			while (u8Array[endPtr] && !(endPtr >= endIdx)) ++endPtr;

			if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
				return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));
			} else {
				var str = '';
				// If building with TextDecoder, we have already computed the string length above, so test loop end condition against that
				while (idx < endPtr) {
					// For UTF8 byte structure, see:
					// http://en.wikipedia.org/wiki/UTF-8#Description
					// https://www.ietf.org/rfc/rfc2279.txt
					// https://tools.ietf.org/html/rfc3629
					var u0 = u8Array[idx++];
					if (!(u0 & 0x80)) {
						str += String.fromCharCode(u0);
						continue;
					}
					var u1 = u8Array[idx++] & 63;
					if ((u0 & 0xE0) == 0xC0) {
						str += String.fromCharCode(((u0 & 31) << 6) | u1);
						continue;
					}
					var u2 = u8Array[idx++] & 63;
					if ((u0 & 0xF0) == 0xE0) {
						u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
					} else {
						u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (u8Array[idx++] & 63);
					}

					if (u0 < 0x10000) {
						str += String.fromCharCode(u0);
					} else {
						var ch = u0 - 0x10000;
						str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
					}
				}
			}
			return str;
		}

		// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a
		// copy of that string as a Javascript String object.
		// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit
		//                 this parameter to scan the string until the first \0 byte. If maxBytesToRead is
		//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the
		//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will
		//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)
		//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may
		//                 throw JS JIT optimizations off, so it is worth to consider consistently using one
		//                 style or the other.
		/**
		 * @param {number} ptr
		 * @param {number=} maxBytesToRead
		 * @return {string}
		 */
		function UTF8ToString(ptr, maxBytesToRead) {
			return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
		}

		// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
		// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
		// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
		// Parameters:
		//   str: the Javascript string to copy.
		//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.
		//   outIdx: The starting offset in the array to begin the copying.
		//   maxBytesToWrite: The maximum number of bytes this function can write to the array.
		//                    This count should include the null terminator,
		//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
		//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
		// Returns the number of bytes written, EXCLUDING the null terminator.

		function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
			if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
				return 0;

			var startIdx = outIdx;
			var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
			for (var i = 0; i < str.length; ++i) {
				// Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
				// See http://unicode.org/faq/utf_bom.html#utf16-3
				// For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
				var u = str.charCodeAt(i); // possibly a lead surrogate
				if (u >= 0xD800 && u <= 0xDFFF) {
					var u1 = str.charCodeAt(++i);
					u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
				}
				if (u <= 0x7F) {
					if (outIdx >= endIdx) break;
					outU8Array[outIdx++] = u;
				} else if (u <= 0x7FF) {
					if (outIdx + 1 >= endIdx) break;
					outU8Array[outIdx++] = 0xC0 | (u >> 6);
					outU8Array[outIdx++] = 0x80 | (u & 63);
				} else if (u <= 0xFFFF) {
					if (outIdx + 2 >= endIdx) break;
					outU8Array[outIdx++] = 0xE0 | (u >> 12);
					outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
					outU8Array[outIdx++] = 0x80 | (u & 63);
				} else {
					if (outIdx + 3 >= endIdx) break;
					outU8Array[outIdx++] = 0xF0 | (u >> 18);
					outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
					outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
					outU8Array[outIdx++] = 0x80 | (u & 63);
				}
			}
			// Null-terminate the pointer to the buffer.
			outU8Array[outIdx] = 0;
			return outIdx - startIdx;
		}

		// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
		// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
		// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
		// Returns the number of bytes written, EXCLUDING the null terminator.

		function stringToUTF8(str, outPtr, maxBytesToWrite) {
			return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
		}

		// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.
		function lengthBytesUTF8(str) {
			var len = 0;
			for (var i = 0; i < str.length; ++i) {
				// Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
				// See http://unicode.org/faq/utf_bom.html#utf16-3
				var u = str.charCodeAt(i); // possibly a lead surrogate
				if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
				if (u <= 0x7F) ++len;
				else if (u <= 0x7FF) len += 2;
				else if (u <= 0xFFFF) len += 3;
				else len += 4;
			}
			return len;
		}

		// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
		// a copy of that string as a Javascript String object.

		var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;

		function UTF16ToString(ptr) {
			var endPtr = ptr;
			// TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
			// Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
			var idx = endPtr >> 1;
			while (HEAP16[idx]) ++idx;
			endPtr = idx << 1;

			if (endPtr - ptr > 32 && UTF16Decoder) {
				return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
			} else {
				var i = 0;

				var str = '';
				while (1) {
					var codeUnit = HEAP16[(((ptr) + (i * 2)) >> 1)];
					if (codeUnit == 0) return str;
					++i;
					// fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
					str += String.fromCharCode(codeUnit);
				}
			}
		}

		// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
		// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
		// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
		// Parameters:
		//   str: the Javascript string to copy.
		//   outPtr: Byte address in Emscripten HEAP where to write the string to.
		//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
		//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
		//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
		// Returns the number of bytes written, EXCLUDING the null terminator.

		function stringToUTF16(str, outPtr, maxBytesToWrite) {
			// Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
			if (maxBytesToWrite === undefined) {
				maxBytesToWrite = 0x7FFFFFFF;
			}
			if (maxBytesToWrite < 2) return 0;
			maxBytesToWrite -= 2; // Null terminator.
			var startPtr = outPtr;
			var numCharsToWrite = (maxBytesToWrite < str.length * 2) ? (maxBytesToWrite / 2) : str.length;
			for (var i = 0; i < numCharsToWrite; ++i) {
				// charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
				var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
				HEAP16[((outPtr) >> 1)] = codeUnit;
				outPtr += 2;
			}
			// Null-terminate the pointer to the HEAP.
			HEAP16[((outPtr) >> 1)] = 0;
			return outPtr - startPtr;
		}

		// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

		function lengthBytesUTF16(str) {
			return str.length * 2;
		}

		function UTF32ToString(ptr) {
			var i = 0;

			var str = '';
			while (1) {
				var utf32 = HEAP32[(((ptr) + (i * 4)) >> 2)];
				if (utf32 == 0)
					return str;
				++i;
				// Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
				// See http://unicode.org/faq/utf_bom.html#utf16-3
				if (utf32 >= 0x10000) {
					var ch = utf32 - 0x10000;
					str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
				} else {
					str += String.fromCharCode(utf32);
				}
			}
		}

		// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
		// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
		// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
		// Parameters:
		//   str: the Javascript string to copy.
		//   outPtr: Byte address in Emscripten HEAP where to write the string to.
		//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
		//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
		//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
		// Returns the number of bytes written, EXCLUDING the null terminator.

		function stringToUTF32(str, outPtr, maxBytesToWrite) {
			// Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
			if (maxBytesToWrite === undefined) {
				maxBytesToWrite = 0x7FFFFFFF;
			}
			if (maxBytesToWrite < 4) return 0;
			var startPtr = outPtr;
			var endPtr = startPtr + maxBytesToWrite - 4;
			for (var i = 0; i < str.length; ++i) {
				// Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
				// See http://unicode.org/faq/utf_bom.html#utf16-3
				var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
				if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
					var trailSurrogate = str.charCodeAt(++i);
					codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
				}
				HEAP32[((outPtr) >> 2)] = codeUnit;
				outPtr += 4;
				if (outPtr + 4 > endPtr) break;
			}
			// Null-terminate the pointer to the HEAP.
			HEAP32[((outPtr) >> 2)] = 0;
			return outPtr - startPtr;
		}

		// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

		function lengthBytesUTF32(str) {
			var len = 0;
			for (var i = 0; i < str.length; ++i) {
				// Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
				// See http://unicode.org/faq/utf_bom.html#utf16-3
				var codeUnit = str.charCodeAt(i);
				if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
				len += 4;
			}

			return len;
		}

		// Allocate heap space for a JS string, and write it there.
		// It is the responsibility of the caller to free() that memory.
		function allocateUTF8(str) {
			var size = lengthBytesUTF8(str) + 1;
			var ret = _malloc(size);
			if (ret) stringToUTF8Array(str, HEAP8, ret, size);
			return ret;
		}

		// Allocate stack space for a JS string, and write it there.
		function allocateUTF8OnStack(str) {
			var size = lengthBytesUTF8(str) + 1;
			var ret = stackAlloc(size);
			stringToUTF8Array(str, HEAP8, ret, size);
			return ret;
		}

		// Deprecated: This function should not be called because it is unsafe and does not provide
		// a maximum length limit of how many bytes it is allowed to write. Prefer calling the
		// function stringToUTF8Array() instead, which takes in a maximum length that can be used
		// to be secure from out of bounds writes.
		/** @deprecated */
		function writeStringToMemory(string, buffer, dontAddNull) {
			warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');

			var /** @type {number} */ lastChar, /** @type {number} */ end;
			if (dontAddNull) {
				// stringToUTF8Array always appends null. If we don't want to do that, remember the
				// character that existed at the location where the null will be placed, and restore
				// that after the write (below).
				end = buffer + lengthBytesUTF8(string);
				lastChar = HEAP8[end];
			}
			stringToUTF8(string, buffer, Infinity);
			if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
		}

		function writeArrayToMemory(array, buffer) {
			HEAP8.set(array, buffer);
		}

		function writeAsciiToMemory(str, buffer, dontAddNull) {
			for (var i = 0; i < str.length; ++i) {
				HEAP8[((buffer++) >> 0)] = str.charCodeAt(i);
			}
			// Null-terminate the pointer to the HEAP.
			if (!dontAddNull) HEAP8[((buffer) >> 0)] = 0;
		}

		function demangle(func) {
			return func;
		}

		function demangleAll(text) {
			var regex =
				/__Z[\w\d_]+/g;
			return text.replace(regex,
				function(x) {
					var y = demangle(x);
					return x === y ? x : (y + ' [' + x + ']');
				});
		}

		function jsStackTrace() {
			var err = new Error();
			if (!err.stack) {
				// IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
				// so try that as a special-case.
				try {
					throw new Error(0);
				} catch (e) {
					err = e;
				}
				if (!err.stack) {
					return '(no stack trace available)';
				}
			}
			return err.stack.toString();
		}

		function stackTrace() {
			var js = jsStackTrace();
			if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
			return demangleAll(js);
		}

		// Memory management

		var PAGE_SIZE = 16384;
		var WASM_PAGE_SIZE = 65536;
		var ASMJS_PAGE_SIZE = 16777216;

		function alignUp(x, multiple) {
			if (x % multiple > 0) {
				x += multiple - (x % multiple);
			}
			return x;
		}

		var HEAP,
			/** @type {ArrayBuffer} */
			buffer,
			/** @type {Int8Array} */
			HEAP8,
			/** @type {Uint8Array} */
			HEAPU8,
			/** @type {Int16Array} */
			HEAP16,
			/** @type {Uint16Array} */
			HEAPU16,
			/** @type {Int32Array} */
			HEAP32,
			/** @type {Uint32Array} */
			HEAPU32,
			/** @type {Float32Array} */
			HEAPF32,
			/** @type {Float64Array} */
			HEAPF64;

		function updateGlobalBufferViews() {
			Module['HEAP8'] = HEAP8 = new Int8Array(buffer);
			Module['HEAP16'] = HEAP16 = new Int16Array(buffer);
			Module['HEAP32'] = HEAP32 = new Int32Array(buffer);
			Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer);
			Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer);
			Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer);
			Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer);
			Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer);
		}

		var STATIC_BASE = 1024,
			STACK_BASE = 7360,
			STACKTOP = STACK_BASE,
			STACK_MAX = 5250240,
			DYNAMIC_BASE = 5250240,
			DYNAMICTOP_PTR = 7328;

		var TOTAL_STACK = 5242880;

		var INITIAL_TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;
		if (INITIAL_TOTAL_MEMORY < TOTAL_STACK) err('TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');

		// Initialize the runtime's memory

		// Use a provided buffer, if there is one, or else allocate a new one
		if (Module['buffer']) {
			buffer = Module['buffer'];
		} else {
			// Use a WebAssembly memory where available
			if (typeof WebAssembly === 'object' && typeof WebAssembly.Memory === 'function') {
				wasmMemory = new WebAssembly.Memory({
					'initial': INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE,
					'maximum': INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE
				});
				buffer = wasmMemory.buffer;
			} else {
				buffer = new ArrayBuffer(INITIAL_TOTAL_MEMORY);
			}
		}
		updateGlobalBufferViews();

		HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;

		// Endianness check (note: assumes compiler arch was little-endian)

		function callRuntimeCallbacks(callbacks) {
			while (callbacks.length > 0) {
				var callback = callbacks.shift();
				if (typeof callback == 'function') {
					callback();
					continue;
				}
				var func = callback.func;
				if (typeof func === 'number') {
					if (callback.arg === undefined) {
						Module['dynCall_v'](func);
					} else {
						Module['dynCall_vi'](func, callback.arg);
					}
				} else {
					func(callback.arg === undefined ? null : callback.arg);
				}
			}
		}

		var __ATPRERUN__ = []; // functions called before the runtime is initialized
		var __ATINIT__ = []; // functions called during startup
		var __ATMAIN__ = []; // functions called when main() is to be run
		var __ATEXIT__ = []; // functions called during shutdown
		var __ATPOSTRUN__ = []; // functions called after the main() is called

		var runtimeInitialized = false;
		var runtimeExited = false;

		function preRun() {
			// compatibility - merge in anything from Module['preRun'] at this time
			if (Module['preRun']) {
				if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
				while (Module['preRun'].length) {
					addOnPreRun(Module['preRun'].shift());
				}
			}
			callRuntimeCallbacks(__ATPRERUN__);
		}

		function initRuntime() {
			runtimeInitialized = true;

			callRuntimeCallbacks(__ATINIT__);
		}

		function preMain() {

			callRuntimeCallbacks(__ATMAIN__);
		}

		function exitRuntime() {
			runtimeExited = true;
		}

		function postRun() {
			// compatibility - merge in anything from Module['postRun'] at this time
			if (Module['postRun']) {
				if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
				while (Module['postRun'].length) {
					addOnPostRun(Module['postRun'].shift());
				}
			}
			callRuntimeCallbacks(__ATPOSTRUN__);
		}

		function addOnPreRun(cb) {
			__ATPRERUN__.unshift(cb);
		}

		function addOnInit(cb) {
			__ATINIT__.unshift(cb);
		}

		function addOnPreMain(cb) {
			__ATMAIN__.unshift(cb);
		}

		function addOnExit(cb) {}

		function addOnPostRun(cb) {
			__ATPOSTRUN__.unshift(cb);
		}

		function unSign(value, bits, ignore) {
			if (value >= 0) {
				return value;
			}
			return bits <= 32 ? 2 * Math.abs(1 << (bits - 1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
				:
				Math.pow(2, bits) + value;
		}

		function reSign(value, bits, ignore) {
			if (value <= 0) {
				return value;
			}
			var half = bits <= 32 ? Math.abs(1 << (bits - 1)) // abs is needed if bits == 32
				:
				Math.pow(2, bits - 1);
			if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
				// but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
				// TODO: In i64 mode 1, resign the two parts separately and safely
				value = -2 * half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
			}
			return value;
		}

		var Math_abs = Math.abs;
		var Math_cos = Math.cos;
		var Math_sin = Math.sin;
		var Math_tan = Math.tan;
		var Math_acos = Math.acos;
		var Math_asin = Math.asin;
		var Math_atan = Math.atan;
		var Math_atan2 = Math.atan2;
		var Math_exp = Math.exp;
		var Math_log = Math.log;
		var Math_sqrt = Math.sqrt;
		var Math_ceil = Math.ceil;
		var Math_floor = Math.floor;
		var Math_pow = Math.pow;
		var Math_imul = Math.imul;
		var Math_fround = Math.fround;
		var Math_round = Math.round;
		var Math_min = Math.min;
		var Math_max = Math.max;
		var Math_clz32 = Math.clz32;
		var Math_trunc = Math.trunc;

		// A counter of dependencies for calling run(). If we need to
		// do asynchronous work before running, increment this and
		// decrement it. Incrementing must happen in a place like
		// Module.preRun (used by emcc to add file preloading).
		// Note that you can add dependencies in preRun, even though
		// it happens right before run - run will be postponed until
		// the dependencies are met.
		var runDependencies = 0;
		var runDependencyWatcher = null;
		var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

		function getUniqueRunDependency(id) {
			return id;
		}

		function addRunDependency(id) {
			runDependencies++;
			if (Module['monitorRunDependencies']) {
				Module['monitorRunDependencies'](runDependencies);
			}
		}

		function removeRunDependency(id) {
			runDependencies--;
			if (Module['monitorRunDependencies']) {
				Module['monitorRunDependencies'](runDependencies);
			}
			if (runDependencies == 0) {
				if (runDependencyWatcher !== null) {
					clearInterval(runDependencyWatcher);
					runDependencyWatcher = null;
				}
				if (dependenciesFulfilled) {
					var callback = dependenciesFulfilled;
					dependenciesFulfilled = null;
					callback(); // can add another dependenciesFulfilled
				}
			}
		}

		Module["preloadedImages"] = {}; // maps url to image data
		Module["preloadedAudios"] = {}; // maps url to audio data

		var memoryInitializer = null;

		// Copyright 2017 The Emscripten Authors.  All rights reserved.
		// Emscripten is available under two separate licenses, the MIT license and the
		// University of Illinois/NCSA Open Source License.  Both these licenses can be
		// found in the LICENSE file.

		// Prefix of data URIs emitted by SINGLE_FILE and related options.
		var dataURIPrefix = 'data:application/octet-stream;base64,';

		// Indicates whether filename is a base64 data URI.
		function isDataURI(filename) {
			return filename.indexOf(dataURIPrefix) === 0;
		}

		if (!isDataURI(wasmBinaryFile)) {
			abort('wasmBinaryFile has to be a data-URI');
		}

		// Create the wasm instance.
		// Receives the wasm imports, returns the exports.
		function createWasm(env) {

			// prepare imports
			var info = {
				'env': env,
				'global': {
					'NaN': NaN,
					'Infinity': Infinity
				},
				'global.Math': Math,
				'asm2wasm': asm2wasmImports
			};
			// Load the wasm module and create an instance of using native support in the JS engine.
			// handle a generated wasm instance, receiving its exports and
			// performing other necessary setup
			function receiveInstance(instance, module) {
				var exports = instance.exports;
				Module['asm'] = exports;
				removeRunDependency('wasm-instantiate');
			}
			addRunDependency('wasm-instantiate');

			function receiveInstantiatedSource(output) {
				// 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.
				// receiveInstance() will swap in the exports (to Module.asm) so they can be called
				// TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
				// When the regression is fixed, can restore the above USE_PTHREADS-enabled path.
				receiveInstance(output['instance']);
			}

			function intArrayFromBase64(s) {
				if (typeof ENVIRONMENT_IS_NODE === "boolean" && ENVIRONMENT_IS_NODE) {
					var buf;
					try {
						buf = Buffer.from(s, "base64")
					} catch (_) {
						buf = new Buffer(s, "base64")
					}
					return new Uint8Array(buf["buffer"], buf["byteOffset"], buf["byteLength"])
				}
				try {
					var decoded = decodeBase64(s);
					var bytes = new Uint8Array(decoded.length);
					for (var i = 0; i < decoded.length; ++i) {
						bytes[i] = decoded.charCodeAt(i)
					}
					return bytes
				} catch (_) {
					throw new Error("Converting base64 string to bytes failed.")
				}
			}
			function tryParseAsDataURI(filename) {
				return intArrayFromBase64(filename.slice(dataURIPrefix.length))
			}
			function instantiateArrayBuffer(receiver) {
				var binary = tryParseAsDataURI(wasmBinaryFile);
				return WebAssembly.instantiate(binary, info).then(receiver, function(reason) {
					err("failed to asynchronously prepare wasm: " + reason);
					abort(reason);
				});
            }
			var decodeBase64 = typeof atob === "function" ? atob : function(input) {
				var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
				var output = "";
				var chr1, chr2, chr3;
				var enc1, enc2, enc3, enc4;
				var i = 0;
				input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
				do {
					enc1 = keyStr.indexOf(input.charAt(i++));
					enc2 = keyStr.indexOf(input.charAt(i++));
					enc3 = keyStr.indexOf(input.charAt(i++));
					enc4 = keyStr.indexOf(input.charAt(i++));
					chr1 = enc1 << 2 | enc2 >> 4;
					chr2 = (enc2 & 15) << 4 | enc3 >> 2;
					chr3 = (enc3 & 3) << 6 | enc4;
					output = output + String.fromCharCode(chr1);
					if (enc3 !== 64) {
						output = output + String.fromCharCode(chr2)
					}
					if (enc4 !== 64) {
						output = output + String.fromCharCode(chr3)
					}
				} while (i < input.length);
				return output
			};

			// User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
			// to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel
			// to any other async startup actions they are performing.
			if (Module['instantiateWasm']) {
				try {
					return Module['instantiateWasm'](info, receiveInstance);
				} catch (e) {
					err('Module.instantiateWasm callback failed with error: ' + e);
					return false;
				}
			}

			instantiateArrayBuffer(receiveInstantiatedSource);
			return {}; // no exports yet; we'll fill them in later
		}

		// Provide an "asm.js function" for the application, called to "link" the asm.js module. We instantiate
		// the wasm module at that time, and it receives imports and provides exports and so forth, the app
		// doesn't need to care that it is wasm or asm.js.

		Module['asm'] = function(global, env, providedBuffer) {
			// memory was already allocated (so js could use the buffer)
			env['memory'] = wasmMemory;
			// import table
			env['table'] = wasmTable = new WebAssembly.Table({
				'initial': 32,
				'maximum': 32,
				'element': 'anyfunc'
			});
			// With the wasm backend __memory_base and __table_base and only needed for
			// relocatable output.
			env['__memory_base'] = 1024; // tell the memory segments where to place themselves
			// table starts at 0 by default (even in dynamic linking, for the main module)
			env['__table_base'] = 0;

			var exports = createWasm(env);
			return exports;
		};

		// === Body ===

		var ASM_CONSTS = [];

		// STATICTOP = STATIC_BASE + 6336;
		/* global initializers */
		/*__ATINIT__.push();*/

		/* no memory initializer */
		var tempDoublePtr = 7344

		function copyTempFloat(ptr) { // functions, because inlining this code increases code size too much
			HEAP8[tempDoublePtr] = HEAP8[ptr];
			HEAP8[tempDoublePtr + 1] = HEAP8[ptr + 1];
			HEAP8[tempDoublePtr + 2] = HEAP8[ptr + 2];
			HEAP8[tempDoublePtr + 3] = HEAP8[ptr + 3];
		}

		function copyTempDouble(ptr) {
			HEAP8[tempDoublePtr] = HEAP8[ptr];
			HEAP8[tempDoublePtr + 1] = HEAP8[ptr + 1];
			HEAP8[tempDoublePtr + 2] = HEAP8[ptr + 2];
			HEAP8[tempDoublePtr + 3] = HEAP8[ptr + 3];
			HEAP8[tempDoublePtr + 4] = HEAP8[ptr + 4];
			HEAP8[tempDoublePtr + 5] = HEAP8[ptr + 5];
			HEAP8[tempDoublePtr + 6] = HEAP8[ptr + 6];
			HEAP8[tempDoublePtr + 7] = HEAP8[ptr + 7];
		}

		// {{PRE_LIBRARY}}

		function ___assert_fail(condition, filename, line, func) {
			abort('Assertion failed: ' + UTF8ToString(condition) + ', at: ' + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);
		}

		var PATH = {
			splitPath: function(filename) {
				var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
				return splitPathRe.exec(filename).slice(1);
			},
			normalizeArray: function(parts, allowAboveRoot) {
				// if the path tries to go above the root, `up` ends up > 0
				var up = 0;
				for (var i = parts.length - 1; i >= 0; i--) {
					var last = parts[i];
					if (last === '.') {
						parts.splice(i, 1);
					} else if (last === '..') {
						parts.splice(i, 1);
						up++;
					} else if (up) {
						parts.splice(i, 1);
						up--;
					}
				}
				// if the path is allowed to go above the root, restore leading ..s
				if (allowAboveRoot) {
					for (; up; up--) {
						parts.unshift('..');
					}
				}
				return parts;
			},
			normalize: function(path) {
				var isAbsolute = path.charAt(0) === '/',
					trailingSlash = path.substr(-1) === '/';
				// Normalize the path
				path = PATH.normalizeArray(path.split('/').filter(function(p) {
					return !!p;
				}), !isAbsolute).join('/');
				if (!path && !isAbsolute) {
					path = '.';
				}
				if (path && trailingSlash) {
					path += '/';
				}
				return (isAbsolute ? '/' : '') + path;
			},
			dirname: function(path) {
				var result = PATH.splitPath(path),
					root = result[0],
					dir = result[1];
				if (!root && !dir) {
					// No dirname whatsoever
					return '.';
				}
				if (dir) {
					// It has a dirname, strip trailing slash
					dir = dir.substr(0, dir.length - 1);
				}
				return root + dir;
			},
			basename: function(path) {
				// EMSCRIPTEN return '/'' for '/', not an empty string
				if (path === '/') return '/';
				var lastSlash = path.lastIndexOf('/');
				if (lastSlash === -1) return path;
				return path.substr(lastSlash + 1);
			},
			extname: function(path) {
				return PATH.splitPath(path)[3];
			},
			join: function() {
				var paths = Array.prototype.slice.call(arguments, 0);
				return PATH.normalize(paths.join('/'));
			},
			join2: function(l, r) {
				return PATH.normalize(l + '/' + r);
			}
		};
		var SYSCALLS = {
			buffers: [null, [],
				[]
			],
			printChar: function(stream, curr) {
				var buffer = SYSCALLS.buffers[stream];
				if (curr === 0 || curr === 10) {
					(stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));
					buffer.length = 0;
				} else {
					buffer.push(curr);
				}
			},
			varargs: 0,
			get: function(varargs) {
				SYSCALLS.varargs += 4;
				var ret = HEAP32[(((SYSCALLS.varargs) - (4)) >> 2)];
				return ret;
			},
			getStr: function() {
				var ret = UTF8ToString(SYSCALLS.get());
				return ret;
			},
			get64: function() {
				var low = SYSCALLS.get(),
					high = SYSCALLS.get();
				return low;
			},
			getZero: function() {
				SYSCALLS.get();
			}
		};

		function ___syscall140(which, varargs) {
			SYSCALLS.varargs = varargs;
			try {
				// llseek
				var stream = SYSCALLS.getStreamFromFD(),
					offset_high = SYSCALLS.get(),
					offset_low = SYSCALLS.get(),
					result = SYSCALLS.get(),
					whence = SYSCALLS.get();
				return 0;
			} catch (e) {
				if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
				return -e.errno;
			}
		}

		function flush_NO_FILESYSTEM() {
			// flush anything remaining in the buffers during shutdown
			var fflush = Module["_fflush"];
			if (fflush) fflush(0);
			var buffers = SYSCALLS.buffers;
			if (buffers[1].length) SYSCALLS.printChar(1, 10);
			if (buffers[2].length) SYSCALLS.printChar(2, 10);
		}

		function ___syscall146(which, varargs) {
			SYSCALLS.varargs = varargs;
			try {
				// writev
				// hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0
				var stream = SYSCALLS.get(),
					iov = SYSCALLS.get(),
					iovcnt = SYSCALLS.get();
				var ret = 0;
				for (var i = 0; i < iovcnt; i++) {
					var ptr = HEAP32[(((iov) + (i * 8)) >> 2)];
					var len = HEAP32[(((iov) + (i * 8 + 4)) >> 2)];
					for (var j = 0; j < len; j++) {
						SYSCALLS.printChar(stream, HEAPU8[ptr + j]);
					}
					ret += len;
				}
				return ret;
			} catch (e) {
				if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
				return -e.errno;
			}
		}

		function ___syscall54(which, varargs) {
			SYSCALLS.varargs = varargs;
			try {
				// ioctl
				return 0;
			} catch (e) {
				if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
				return -e.errno;
			}
		}

		function ___syscall6(which, varargs) {
			SYSCALLS.varargs = varargs;
			try {
				// close
				var stream = SYSCALLS.getStreamFromFD();
				return 0;
			} catch (e) {
				if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
				return -e.errno;
			}
		}

		function _emscripten_get_heap_size() {
			return HEAP8.length;
		}

		function _emscripten_memcpy_big(dest, src, num) {
			HEAPU8.set(HEAPU8.subarray(src, src + num), dest);
		}

		function ___setErrNo(value) {
			if (Module['___errno_location']) HEAP32[((Module['___errno_location']()) >> 2)] = value;
			return value;
		}

		function abortOnCannotGrowMemory(requestedSize) {
			abort('OOM');
		}

		function _emscripten_resize_heap(requestedSize) {
			abortOnCannotGrowMemory(requestedSize);
		}
		var ASSERTIONS = false;

		// Copyright 2017 The Emscripten Authors.  All rights reserved.
		// Emscripten is available under two separate licenses, the MIT license and the
		// University of Illinois/NCSA Open Source License.  Both these licenses can be
		// found in the LICENSE file.

		/** @type {function(string, boolean=, number=)} */
		function intArrayFromString(stringy, dontAddNull, length) {
			var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
			var u8array = new Array(len);
			var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
			if (dontAddNull) u8array.length = numBytesWritten;
			return u8array;
		}

		function intArrayToString(array) {
			var ret = [];
			for (var i = 0; i < array.length; i++) {
				var chr = array[i];
				if (chr > 0xFF) {
					if (ASSERTIONS) {
						assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
					}
					chr &= 0xFF;
				}
				ret.push(String.fromCharCode(chr));
			}
			return ret.join('');
		}

		// ASM_LIBRARY EXTERN PRIMITIVES: Int8Array,Int32Array

		var asmGlobalArg = {}

		var asmLibraryArg = {
			"abort": abort,
			"setTempRet0": setTempRet0,
			"getTempRet0": getTempRet0,
			"___assert_fail": ___assert_fail,
			"___setErrNo": ___setErrNo,
			"___syscall140": ___syscall140,
			"___syscall146": ___syscall146,
			"___syscall54": ___syscall54,
			"___syscall6": ___syscall6,
			"_emscripten_get_heap_size": _emscripten_get_heap_size,
			"_emscripten_memcpy_big": _emscripten_memcpy_big,
			"_emscripten_resize_heap": _emscripten_resize_heap,
			"abortOnCannotGrowMemory": abortOnCannotGrowMemory,
			"flush_NO_FILESYSTEM": flush_NO_FILESYSTEM,
			"tempDoublePtr": tempDoublePtr,
			"DYNAMICTOP_PTR": DYNAMICTOP_PTR
		}
		// EMSCRIPTEN_START_ASM
		var asm = Module["asm"] // EMSCRIPTEN_END_ASM
		(asmGlobalArg, asmLibraryArg, buffer);

		Module["asm"] = asm;
		var ___errno_location = Module["___errno_location"] = function() {
			return Module["asm"]["___errno_location"].apply(null, arguments)
		};

		var _free = Module["_free"] = function() {
			return Module["asm"]["_free"].apply(null, arguments)
		};

		var _main = Module["_main"] = function() {
			return Module["asm"]["_main"].apply(null, arguments)
		};

		var _malloc = Module["_malloc"] = function() {
			return Module["asm"]["_malloc"].apply(null, arguments)
		};

		var _memcpy = Module["_memcpy"] = function() {
			return Module["asm"]["_memcpy"].apply(null, arguments)
		};

		var _memset = Module["_memset"] = function() {
			return Module["asm"]["_memset"].apply(null, arguments)
		};

		var _process_data = Module["_process_data"] = function() {
			return Module["asm"]["_process_data"].apply(null, arguments)
		};

		var _sbrk = Module["_sbrk"] = function() {
			return Module["asm"]["_sbrk"].apply(null, arguments)
		};

		var _setmode = Module["_setmode"] = function() {
			return Module["asm"]["_setmode"].apply(null, arguments)
		};

		var establishStackSpace = Module["establishStackSpace"] = function() {
			return Module["asm"]["establishStackSpace"].apply(null, arguments)
		};

		var stackAlloc = Module["stackAlloc"] = function() {
			return Module["asm"]["stackAlloc"].apply(null, arguments)
		};

		var stackRestore = Module["stackRestore"] = function() {
			return Module["asm"]["stackRestore"].apply(null, arguments)
		};

		var stackSave = Module["stackSave"] = function() {
			return Module["asm"]["stackSave"].apply(null, arguments)
		};

		var dynCall_ii = Module["dynCall_ii"] = function() {
			return Module["asm"]["dynCall_ii"].apply(null, arguments)
		};

		var dynCall_iii = Module["dynCall_iii"] = function() {
			return Module["asm"]["dynCall_iii"].apply(null, arguments)
		};

		var dynCall_iiii = Module["dynCall_iiii"] = function() {
			return Module["asm"]["dynCall_iiii"].apply(null, arguments)
		};

		var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = function() {
			return Module["asm"]["dynCall_iiiiiiii"].apply(null, arguments)
		};

		var dynCall_iiiiiiiii = Module["dynCall_iiiiiiiii"] = function() {
			return Module["asm"]["dynCall_iiiiiiiii"].apply(null, arguments)
		};

		var dynCall_jiji = Module["dynCall_jiji"] = function() {
			return Module["asm"]["dynCall_jiji"].apply(null, arguments)
		};

		var dynCall_v = Module["dynCall_v"] = function() {
			return Module["asm"]["dynCall_v"].apply(null, arguments)
		};

		var dynCall_vi = Module["dynCall_vi"] = function() {
			return Module["asm"]["dynCall_vi"].apply(null, arguments)
		};

		var dynCall_viiiiiii = Module["dynCall_viiiiiii"] = function() {
			return Module["asm"]["dynCall_viiiiiii"].apply(null, arguments)
		};;

		// === Auto-generated postamble setup entry stuff ===

		Module['asm'] = asm;

		Module["ccall"] = ccall;
		Module["cwrap"] = cwrap;

		/**
		 * @constructor
		 * @extends {Error}
		 * @this {ExitStatus}
		 */
		function ExitStatus(status) {
			this.name = "ExitStatus";
			this.message = "Program terminated with exit(" + status + ")";
			this.status = status;
		};
		ExitStatus.prototype = new Error();
		ExitStatus.prototype.constructor = ExitStatus;

		var calledMain = false;

		dependenciesFulfilled = function runCaller() {
			// If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
			if (!Module['calledRun']) run();
			if (!Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
		}

		Module['callMain'] = function callMain(args) {

			args = args || [];

			var argc = args.length + 1;
			var argv = stackAlloc((argc + 1) * 4);
			HEAP32[argv >> 2] = allocateUTF8OnStack(Module['thisProgram']);
			for (var i = 1; i < argc; i++) {
				HEAP32[(argv >> 2) + i] = allocateUTF8OnStack(args[i - 1]);
			}
			HEAP32[(argv >> 2) + argc] = 0;


			try {

				var ret = Module['_main'](argc, argv, 0);


				// if we're not running an evented main loop, it's time to exit
				exit(ret, /* implicit = */ true);
			} catch (e) {
				if (e instanceof ExitStatus) {
					// exit() throws this once it's done to make sure execution
					// has been stopped completely
					return;
				} else if (e == 'SimulateInfiniteLoop') {
					// running an evented main loop, don't immediately exit
					Module['noExitRuntime'] = true;
					return;
				} else {
					var toLog = e;
					if (e && typeof e === 'object' && e.stack) {
						toLog = [e, e.stack];
					}
					err('exception thrown: ' + toLog);
					Module['quit'](1, e);
				}
			} finally {
				calledMain = true;
			}
		}


		/** @type {function(Array=)} */
		function run(args) {
			args = args || Module['arguments'];

			if (runDependencies > 0) {
				return;
			}

			preRun();

			if (runDependencies > 0) return; // a preRun added a dependency, run will be called later
			if (Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame

			function doRun() {
				if (Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening
				Module['calledRun'] = true;
				if (ABORT) return;
				initRuntime();
				preMain();
				readyPromiseResolve(Module);
				if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();
				if (Module['_main'] && shouldRunNow) Module['callMain'](args);
				postRun();
			}

			if (Module['setStatus']) {
				Module['setStatus']('Running...');
				setTimeout(function() {
					setTimeout(function() {
						Module['setStatus']('');
					}, 1);
					doRun();
				}, 1);
			} else {
				doRun();
			}
		}
		Module['run'] = run;


		function exit(status, implicit) {

			// if this is just main exit-ing implicitly, and the status is 0, then we
			// don't need to do anything here and can just leave. if the status is
			// non-zero, though, then we need to report it.
			// (we may have warned about this earlier, if a situation justifies doing so)
			if (implicit && Module['noExitRuntime'] && status === 0) {
				return;
			}

			if (Module['noExitRuntime']) {} else {

				ABORT = true;
				EXITSTATUS = status;

				exitRuntime();

				if (Module['onExit']) Module['onExit'](status);
			}

			Module['quit'](status, new ExitStatus(status));
		}

		var abortDecorators = [];

		function abort(what) {
			if (Module['onAbort']) {
				Module['onAbort'](what);
			}

			if (what !== undefined) {
				out(what);
				err(what);
				what = '"' + what + '"';
			} else {
				what = '';
			}

			ABORT = true;
			EXITSTATUS = 1;

			throw 'abort(' + what + '). Build with -s ASSERTIONS=1 for more info.';
		}
		Module['abort'] = abort;

		if (Module['preInit']) {
			if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
			while (Module['preInit'].length > 0) {
				Module['preInit'].pop()();
			}
		}

		// shouldRunNow refers to calling main(), not run().
		var shouldRunNow = true;
		if (Module['noInitialRun']) {
			shouldRunNow = false;
		}

		Module["noExitRuntime"] = true;

		run();

		// {{MODULE_ADDITIONS}}

        return WebRtcVad.ready;
    });
})();
